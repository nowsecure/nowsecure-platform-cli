#
directive @internal on FIELD | FIELD_DEFINITION | ARGUMENT_DEFINITION

#
directive @admin on FIELD | FIELD_DEFINITION | ARGUMENT_DEFINITION

#
directive @hidden on FIELD | FIELD_DEFINITION | ARGUMENT_DEFINITION

#
directive @hiddenFor(
  role: String
) on SCHEMA | FIELD | FIELD_DEFINITION | ARGUMENT_DEFINITION

#
directive @feature(
  featureId: String
) on SCHEMA | OBJECT | FIELD | FIELD_DEFINITION | ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

#
directive @experimental on FIELD | FIELD_DEFINITION | ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

#
directive @authenticated on SCHEMA | FIELD | FIELD_DEFINITION

#
directive @onlyWithoutAuth on FIELD | FIELD_DEFINITION

# NowSecure graph query endpoints
type Query {
  #
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  alerts: AlertsQuery!

  #
  findingChecks(checkIds: [FindingCheckID!]): [FindingCheck!]!
    @deprecated(reason: "use finding.list($ids) instead")

  #
  findings: FindingsQuery!

  #
  my: MyQuery!

  #
  # ---
  #
  # ğŸ›¡ï¸ ** ORG ADMIN ** ğŸ›¡ï¸
  group: GroupQuery!

  #
  # ---
  #
  # ğŸ›¡ï¸ ** ORG ADMIN ** ğŸ›¡ï¸
  user: UserQuery!

  #
  intel: IntelQuery!

  #
  integrations: IntegrationQuery!

  #
  auto: AutoQuery!

  #
  audit: AuditQuery!

  #
  global: GlobalQuery!

  #
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  feature: FeatureFlagQuery
}

#
type AlertsQuery {
  #
  myAlerts(isRead: Boolean, sortDescending: Boolean): [Alert!]!

  #
  groupAlertPolicy(ref: UUID!): GroupAlertPolicy!
}

#
interface Alert {
  #
  id: Int!

  #
  eventType: String!

  #
  deliveryChannel: AlertDeliveryChannelEnum!

  #
  createdAt: DateTime!

  #
  readAt: DateTime
}

#
enum AlertDeliveryChannelEnum {
  #
  EMAIL

  #
  INAPP

  #
  INTEGRATIONS
}

# A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
scalar DateTime

# The UUID scalar type represents a UUID.
scalar UUID

#
type GroupAlertPolicy {
  #
  ref: UUID!

  #
  email: GroupEmailAlertPolicy!

  #
  events: AlertPolicies!
}

#
type GroupEmailAlertPolicy {
  #
  sendToDefaultAddresses: Boolean!

  #
  otherAddresses: [String!]!

  #
  isSignInRequired: Boolean!

  #
  isDigestEnabled: Boolean!

  #
  digestFrequency: AlertFrequency!
}

#
type AlertFrequency {
  #
  value: Int!

  #
  unit: AlertFrequencyUnitEnum!
}

#
enum AlertFrequencyUnitEnum {
  #
  MINUTE

  #
  HOUR

  #
  DAY

  #
  WEEK
}

#
type AlertPolicies {
  #
  appConfigUpdated: AppConfigUpdatedAlertPolicy!

  #
  appStale: AppStaleAlertPolicy!

  #
  assessmentDone: AssessmentDoneAlertPolicy!

  #
  findingsUpdated: FindingsUpdatedAlertPolicy!
}

#
type AppConfigUpdatedAlertPolicy implements AlertPolicy {
  #
  deliveryChannels: [AlertDeliveryChannelEnum!]!
}

#
interface AlertPolicy {
  #
  deliveryChannels: [AlertDeliveryChannelEnum!]!
}

#
type AppStaleAlertPolicy implements AlertPolicy {
  #
  deliveryChannels: [AlertDeliveryChannelEnum!]!

  #
  interval: AlertFrequency!
}

#
type AssessmentDoneAlertPolicy implements AlertPolicy {
  #
  deliveryChannels: [AlertDeliveryChannelEnum!]!

  #
  onEveryAssessment: Boolean!

  #
  onIncompleteOrFailed: Boolean!

  #
  onScore: Boolean!

  #
  maximumScore: Int!

  #
  onVulnerabilities: Boolean!

  #
  vulnerabilities: [String!]!

  #
  onNewVulnerabilities: Boolean!

  #
  onNetworkConnectionCountries: Boolean!

  #
  networkConnectionCountries: [CountryID!]!
}

# [ISO 3166-1 alpha-2 code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) enum
enum CountryID {
  # Andorra
  AD

  # United Arab Emirates
  AE

  # Afghanistan
  AF

  # Antigua and Barbuda
  AG

  # Anguilla
  AI

  # Albania
  AL

  # Armenia
  AM

  # Angola
  AO

  # Antarctica
  AQ

  # Argentina
  AR

  # American Samoa
  AS

  # Austria
  AT

  # Australia
  AU

  # Aruba
  AW

  # Aland Islands
  AX

  # Azerbaijan
  AZ

  # Bosnia and Herzegovina
  BA

  # Barbados
  BB

  # Bangladesh
  BD

  # Belgium
  BE

  # Burkina Faso
  BF

  # Bulgaria
  BG

  # Bahrain
  BH

  # Burundi
  BI

  # Benin
  BJ

  # Saint Barthelemy
  BL

  # Bermuda
  BM

  # Brunei Darussalam
  BN

  # Bolivia, Plurinational State of
  BO

  # Bonaire, Sint Eustatius and Saba
  BQ

  # Brazil
  BR

  # Bahamas
  BS

  # Bhutan
  BT

  # Bouvet Island
  BV

  # Botswana
  BW

  # Belarus
  BY

  # Belize
  BZ

  # Canada
  CA

  # Cocos (Keeling) Islands
  CC

  # Congo, The Democratic Republic of The
  CD

  # Central African Republic
  CF

  # Congo
  CG

  # Switzerland
  CH

  # Cote D`ivoire
  CI

  # Cook Islands
  CK

  # Chile
  CL

  # Cameroon
  CM

  # China
  CN

  # Colombia
  CO

  # Costa Rica
  CR

  # Cuba
  CU

  # Cabo Verde
  CV

  # Curacao
  CW

  # Christmas Island
  CX

  # Cyprus
  CY

  # Czech Republic
  CZ

  # Germany
  DE

  # Djibouti
  DJ

  # Denmark
  DK

  # Dominica
  DM

  # Dominican Republic
  DO

  # Algeria
  DZ

  # Ecuador
  EC

  # Estonia
  EE

  # Egypt
  EG

  # Western Sahara
  EH

  # Eritrea
  ER

  # Spain
  ES

  # Ethiopia
  ET

  # Finland
  FI

  # Fiji
  FJ

  # Falkland Islands (Malvinas)
  FK

  # Micronesia, Federated States of
  FM

  # Faroe Islands
  FO

  # France
  FR

  # Gabon
  GA

  # United Kingdom
  GB

  # Grenada
  GD

  # Georgia
  GE

  # French Guiana
  GF

  # Guernsey
  GG

  # Ghana
  GH

  # Gibraltar
  GI

  # Greenland
  GL

  # Gambia
  GM

  # Guinea
  GN

  # Guadeloupe
  GP

  # Equatorial Guinea
  GQ

  # Greece
  GR

  # South Georgia and The South Sandwich Islands
  GS

  # Guatemala
  GT

  # Guam
  GU

  # Guinea-Bissau
  GW

  # Guyana
  GY

  # Hong Kong
  HK

  # Heard Island and Mcdonald Islands
  HM

  # Honduras
  HN

  # Croatia
  HR

  # Haiti
  HT

  # Hungary
  HU

  # Indonesia
  ID

  # Ireland
  IE

  # Israel
  IL

  # Isle of Man
  IM

  # India
  IN

  # British Indian Ocean Territory
  IO

  # Iraq
  IQ

  # Iran, Islamic Republic of
  IR

  # Iceland
  IS

  # Italy
  IT

  # Jersey
  JE

  # Jamaica
  JM

  # Jordan
  JO

  # Japan
  JP

  # Kenya
  KE

  # Kyrgyzstan
  KG

  # Cambodia
  KH

  # Kiribati
  KI

  # Comoros
  KM

  # Saint Kitts and Nevis
  KN

  # Korea, Democratic People`s Republic of
  KP

  # Korea, Republic of
  KR

  # Kuwait
  KW

  # Cayman Islands
  KY

  # Kazakhstan
  KZ

  # Lao People`s Democratic Republic
  LA

  # Lebanon
  LB

  # Saint Lucia
  LC

  # Liechtenstein
  LI

  # Sri Lanka
  LK

  # Liberia
  LR

  # Lesotho
  LS

  # Lithuania
  LT

  # Luxembourg
  LU

  # Latvia
  LV

  # Libya
  LY

  # Morocco
  MA

  # Monaco
  MC

  # Moldova, Republic of
  MD

  # Montenegro
  ME

  # Saint Martin (French Part)
  MF

  # Madagascar
  MG

  # Marshall Islands
  MH

  # Macedonia, The Former Yugoslav Republic of
  MK

  # Mali
  ML

  # Myanmar
  MM

  # Mongolia
  MN

  # Macao
  MO

  # Northern Mariana Islands
  MP

  # Martinique
  MQ

  # Mauritania
  MR

  # Montserrat
  MS

  # Malta
  MT

  # Mauritius
  MU

  # Maldives
  MV

  # Malawi
  MW

  # Mexico
  MX

  # Malaysia
  MY

  # Mozambique
  MZ

  # Namibia
  NA

  # New Caledonia
  NC

  # Niger
  NE

  # Norfolk Island
  NF

  # Nigeria
  NG

  # Nicaragua
  NI

  # Netherlands
  NL

  # Norway
  NO

  # Nepal
  NP

  # Nauru
  NR

  # Niue
  NU

  # New Zealand
  NZ

  # Oman
  OM

  # Panama
  PA

  # Peru
  PE

  # French Polynesia
  PF

  # Papua New Guinea
  PG

  # Philippines
  PH

  # Pakistan
  PK

  # Poland
  PL

  # Saint Pierre and Miquelon
  PM

  # Pitcairn
  PN

  # Puerto Rico
  PR

  # Palestine, State of
  PS

  # Portugal
  PT

  # Palau
  PW

  # Paraguay
  PY

  # Qatar
  QA

  # Reunion
  RE

  # Romania
  RO

  # Serbia
  RS

  # Russian Federation
  RU

  # Rwanda
  RW

  # Saudi Arabia
  SA

  # Solomon Islands
  SB

  # Seychelles
  SC

  # Sudan
  SD

  # Sweden
  SE

  # Singapore
  SG

  # Saint Helena, Ascension and Tristan Da Cunha
  SH

  # Slovenia
  SI

  # Svalbard and Jan Mayen
  SJ

  # Slovakia
  SK

  # Sierra Leone
  SL

  # San Marino
  SM

  # Senegal
  SN

  # Somalia
  SO

  # Suriname
  SR

  # South Sudan
  SS

  # Sao Tome and Principe
  ST

  # El Salvador
  SV

  # Sint Maarten (Dutch Part)
  SX

  # Syrian Arab Republic
  SY

  # Swaziland
  SZ

  # Turks and Caicos Islands
  TC

  # Chad
  TD

  # French Southern Territories
  TF

  # Togo
  TG

  # Thailand
  TH

  # Tajikistan
  TJ

  # Tokelau
  TK

  # Timor-Leste
  TL

  # Turkmenistan
  TM

  # Tunisia
  TN

  # Tonga
  TO

  # Turkey
  TR

  # Trinidad and Tobago
  TT

  # Tuvalu
  TV

  # Taiwan, Province of China
  TW

  # Tanzania, United Republic of
  TZ

  # Ukraine
  UA

  # Uganda
  UG

  # United States Minor Outlying Islands
  UM

  # United States
  US

  # Uruguay
  UY

  # Uzbekistan
  UZ

  # Holy See
  VA

  # Saint Vincent and The Grenadines
  VC

  # Venezuela, Bolivarian Republic of
  VE

  # Virgin Islands, British
  VG

  # Virgin Islands, U.S.
  VI

  # Viet Nam
  VN

  # Vanuatu
  VU

  # Wallis and Futuna
  WF

  # Samoa
  WS

  # Yemen
  YE

  # Mayotte
  YT

  # South Africa
  ZA

  # Zambia
  ZM

  # Zimbabwe
  ZW
}

#
type FindingsUpdatedAlertPolicy implements AlertPolicy {
  #
  deliveryChannels: [AlertDeliveryChannelEnum!]!
}

#
enum AlertStatus {
  #
  QUEUED

  #
  DELIVERED

  #
  FAILED
}

#
type IntegrationsAlert {
  #
  createdAt: DateTime!

  #
  processedAt: DateTime

  #
  errorMessage: String

  #
  status: AlertStatus!

  #
  alertEvent: IntegrationsAlertAlertEvent!
}

#
union IntegrationsAlertAlertEvent =
    VulnerabilityAlertEvent
  | AssessmentFindingAdjustmentAlertEvent
  | AppFindingAdjustmentAlertEvent

#
type VulnerabilityAlertEvent implements IntegrationsAlertEvent {
  #
  eventType: IntegrationsAlertEventType!

  #
  createdAt: DateTime!

  #
  processedAt: DateTime

  #
  vulnId: Int!

  #
  vulnEvent: VulnerabilityAlertEventVulnEvent!

  #
  findingId: String!

  #
  application: AutoApplication!

  #
  assessment: AutoAssessment!
}

#
interface IntegrationsAlertEvent {
  #
  eventType: IntegrationsAlertEventType!

  #
  createdAt: DateTime!

  #
  processedAt: DateTime
}

#
enum IntegrationsAlertEventType {
  #
  VULNERABILITY

  #
  ASSESSMENT_FINDING_ADJUSTMENT

  #
  APP_FINDING_ADJUSTMENT
}

#
enum VulnerabilityAlertEventVulnEvent {
  #
  created

  #
  updated

  #
  closed
}

#
type AutoApplication implements Application {
  # Unique identifier for an assessment
  ref: UUID!

  # Reference to associated group
  groupRef: UUID! @deprecated(reason: "use group.ref instead")

  # Associated group
  group: AutoGroup!

  # Platform targeted by assessment (ios or android)
  platformType: PlatformEnum!

  # Package name (android) or bundle id string (iOS)
  packageKey: String!

  # Current application title, which may be inferred from build metadata or specified explicitly.
  title: String

  # URL of the current icon associated with this app record.
  #
  # Note: this will actually be a data url, and could be absurdly large, and would be better to resolve from the build entity.
  # This field should probably be deprecated.
  iconURL: String

  # Digest of the build that was uploaded last
  lastUploadedBuildDigest: String

  # Reference to the build that was uploaded last
  lastUploadedBuildRef: String

  # Build that was uploaded last
  lastUploadedBuild: AutoBuild

  # All assessments for this application.
  assessments(
    # Maximum number of assessments to resolve per application.
    limit: Int

    # Filter for assessments with a specific status, e.g. status: 'completed'.
    status: String

    # Filter for assessments created >= creation date.
    since: DateTime

    # Filter for assessments created > creation date.
    after: DateTime

    # Filter for assessments created < creation date.
    before: DateTime

    # Filter for assessments created <= creation date.
    until: DateTime

    # Reverse sort order.
    reverse: Boolean

    # Optionally include all deleted assessments.
    includeDeleted: Boolean

    # Filter by default or custom config used.
    defaultConfig: Boolean

    # Filter assessments by the binary source.
    appstoreDownload: Boolean

    # Filter assessments by debug mode state
    debugMode: Boolean

    # Filter assessments by favorite.
    favorite: Boolean
  ): [AutoAssessment!]!

  # When the application was created.
  createdAt: DateTime!

  # When the application was archived (null if not archived)
  archivedAt: DateTime

  # Link to app store
  appstoreApplicationKey: String

  # Digest of the build that was uploaded for test runner
  testRunnerBuildDigest: String

  # Configuration level available for analysis on this app
  analysisConfigLevel: AnalysisConfigLevel

  # Flag to indicate when application has been put into experimental new debug mode to fail fast dynamic analysis.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  isDebugMode: Boolean!

  # The associated IntelApplication (if it exists) linked by platformType::packageKey
  published: IntelApplication

  # The most recently requested assessment.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  latestAssessment: AutoAssessment

  # Most recent completed and scored assessment record
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  latestCompleteAssessment: AutoAssessment

  #
  appStoreApplicationKey: String
    @deprecated(reason: "Use appstoreApplicationKey.")

  #
  id: ID! @deprecated(reason: "Use ref.")

  #
  package: String! @deprecated(reason: "Use packageKey.")

  #
  platform: PlatformEnum! @deprecated(reason: "Use platformType.")

  #
  integrationConfig: IntegrationConfig

  # Analysis configuration overrides specified by user to be used by default for specified application
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  analysisConfig: AnalysisConfigEntry!

  # The Policy currently targetting this application.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  policy: Policy!
}

# Application package instance, as identified by a device of associated platform
interface Application {
  #
  platformType: PlatformEnum!

  #
  packageKey: String!

  #
  title: String

  #
  iconURL: String
}

#
enum PlatformEnum {
  #
  android

  #
  ios
}

# Platform group entity, for RBAC management within an organization.
type AutoGroup {
  # Unique identifier for a group
  ref: UUID!

  # Internal integer id for group
  id: ID!

  # Name of the group
  name: String!

  # When the group was created.
  createdAt: DateTime!

  # Whether or not group is active
  active: Boolean!

  # List users currently in this group
  # ---
  #
  # ğŸ›¡ï¸ ** ORG ADMIN ** ğŸ›¡ï¸
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  users: [User!]

  # Counts number of current (unarchived) applications within group
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  currentApplicationCount: Int!

  # Counts number of completed assessments within unarchived applications in group
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  completedAssessmentCount: Int!

  # Counts number of completed baseline assessments within unarchived applications in group
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  completedBaselineAssessmentCount: Int!

  # Counts number of completed advanced assessments within unarchived applications in group
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  completedAdvancedAssessmentCount: Int!

  #
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  outstandingAssessmentCount: Int!

  #
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  namedAnalysisConfigTemplates: [NamedAnalysisConfigTemplate!]!

  #
  settings: [Setting]

  # Full text field where an organization can keep arbitrary note about a group entity.
  note: String
}

# Platform user entity.
type User {
  # User's UUID entity ref.
  ref: UUID!

  # Organization entity associated with user.
  organization: Organization

  # User name
  name: String!

  # User email
  email: String

  # Timestamp for when user entity was first added to system.
  # ---
  #
  # ğŸ›¡ï¸ ** ORG ADMIN ** ğŸ›¡ï¸
  createdAt: DateTime

  # User email
  # ---
  #
  # ğŸ›¡ï¸ ** ORG ADMIN ** ğŸ›¡ï¸
  active: Boolean!

  #
  groups: [AutoGroup]!

  # Role and permissions for the user
  role: Role

  # Full text field where an organization can keep arbitrary note about a user entity.
  note: String
}

# Platform organization entity.
type Organization {
  # Organization's integer identifier.
  id: ID!

  # Name associated with organization, if any.
  name: String

  # Limit plan definition associated with organization.
  plan: LimitPlanQuery

  # Query resource usage by resource type.
  usage: ResourceUsageQuery!

  # Timestamp for when user entity was first added to system.
  # ---
  #
  # ğŸ›¡ï¸ ** ORG ADMIN ** ğŸ›¡ï¸
  createdAt: DateTime

  # Enumerate groups within org.
  groups(
    # Optional boolean param to limit to just active groups
    active: Boolean
  ): [AutoGroup!]!

  # Enumerate users within org.
  users(
    # Optional boolean param to limit to just active users
    active: Boolean

    # Limit results
    limit: Int = 10
  ): [User!]!

  # List organization user invitations
  # ---
  #
  # ğŸ›¡ï¸ ** ORG ADMIN ** ğŸ›¡ï¸
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  invitations: [UserInvitation!]

  # Capabilities this org can define
  # ---
  #
  # ğŸ›¡ï¸ ** ORG ADMIN ** ğŸ›¡ï¸
  capabilities: [Capability!]

  # Enumerate the roles available within the organization
  roles: [Role!]!

  # Enumerate the tokens created by users in the organization
  # ---
  #
  # ğŸ›¡ï¸ ** ORG ADMIN ** ğŸ›¡ï¸
  tokens(
    # Include revoked tokens in the list
    includeRevoked: Boolean

    # List tokens for a specific user in the organization
    userRef: UUID

    # List tokens with names matching "search"
    search: String
  ): [Token!]

  # The active orgnization policy for this organization.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  policy: Policy!
}

# Platform usage limit plan definition.
type LimitPlanQuery {
  # List of plan limits, one per resource type (e.g. "assessment", "application").
  limits: [ResourceUsage!]
}

# Platform organization limit definition.
type ResourceUsage {
  # Type of resource being limited (e.g. "assessment", "application".
  type: String! @deprecated(reason: "Use resourceType")

  # Type of resource being limited (e.g. "assessment", "application".
  resourceType: ResourceType!

  # Usage limit maximum associated with resource type.
  limit: Int

  # Whether the resource allows "unlimited" use
  unlimited: Boolean!

  # Whether the limit has been reached
  reached: Boolean!

  # Total resource usage
  total: Int!

  # Current resource count
  count: Int! @deprecated(reason: "Use total")
}

#
enum ResourceType {
  # An application with baseline analysis (system default configuration) enabled
  BASELINE_APP

  # An application with advanced analysis (custom values and script configuration) enabled
  ADVANCED_APP

  # An assessment
  ASSESSMENT
}

# Resource usage query.
type ResourceUsageQuery {
  # Application usage (advanced configuration enabled)
  application: ResourceUsage!

  # Baseline application usage (analysis with system default configuration enabled)
  baseline: ResourceUsage!

  # Assessment usage query.
  assessment: ResourceUsage!
}

# Organization user invitations
type UserInvitation {
  #
  ref: UUID!

  #
  name: String!

  #
  email: String!

  #
  role: Role!

  #
  groups: [AutoGroup!]!

  #
  expiredAt: Date!
}

# Platform RBAC role
type Role {
  #
  ref: UUID

  #
  name: String!

  #
  label: String!

  #
  description: String

  # Default permission set for this role
  defaultPermissions: [Permission!]!

  # Customized permission set for this role, if set
  permissions: [Permission!]

  #
  createdAt: DateTime!

  #
  updatedAt: DateTime!

  #
  expiresAt: DateTime
}

#
type Permission {
  #
  ref: UUID!

  #
  label: String!

  # List of privileges granted by this permission
  privileges: [String!]

  #
  createdAt: DateTime!

  #
  updatedAt: DateTime!
}

# A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
scalar Date

# Platform ABAC like Capabilities
type Capability {
  #
  ref: UUID

  #
  label: String

  #
  namespace: String

  #
  resourceType: String

  #
  actions: [String!]

  #
  scope: String

  #
  category: String
}

#
type Token {
  #
  ref: UUID!

  #
  user: User!

  #
  name: String

  #
  createdAt: DateTime!

  #
  revokedAt: DateTime
}

# A NowSecure policy
type Policy {
  # A unique identifier for the policy
  ref: UUID!

  # A custom name assigned to the policy
  name: EntityName!

  # The policy this policy is tracking
  trackedPolicy: Policy

  # Whether the policy is the default NowSecure policy
  isDefault: Boolean!

  # Whether the policy is managed by NowSecure
  isNSManaged: Boolean!

  # Whether this policy is on or off
  enabled: Boolean!

  # The type of entity that can be targeted by this policy
  targetType: PolicyTargetEntityType

  # A list of entities targeted by this policy
  targets: [PolicyTarget!]!

  # The latest version of this policy
  latestVersion: PolicyVersion!

  # A specific version of this policy, specified by the version number
  version(
    # The policy version number to get
    number: Int!
  ): PolicyVersion

  # A list of all the version of this policy
  allVersions: [PolicyVersion!]!

  # When the policy was created
  createdAt: DateTime!

  # The UUID ref of the user who created this policy
  createdBy: UUID

  # When the policy was last updated
  updatedAt: DateTime!

  # When the policy was archived. If null, the policy has not been archived
  archivedAt: DateTime
}

# An EntityName is a String between 1 and 50 characters in length
scalar EntityName

# The type of entity a policy is targetting
enum PolicyTargetEntityType {
  #
  ORGANIZATION

  #
  APPLICATION
}

# An entity targeted by a policy
type PolicyTarget {
  # The type of the targeted entity
  type: PolicyTargetEntityType!

  # The identifying UUID ref of the targeted entity
  ref: UUID!
}

# A version of a NowSecure policy
type PolicyVersion {
  # A unique identifier for the policy version
  ref: UUID!

  # The UUID ref of the Policy this PolicyVersion belongs to
  policyRef: UUID!

  # The integer version of the policy. Each change to the policy's findings, regulations or policyCategories increments the version number
  version: Int!

  # The version of the tracked policy this policy version is tracking
  trackedVersion: Int

  # The UUID ref of the policy version this policy version is update to date with
  trackedVersionRef: UUID

  # A textual note describing the policy version's content
  note: Note

  # A list of PolicyFindings, each describing the policy's overridden behaviour for a finding
  findings: [PolicyFinding!]!

  # A list of PolicyRegulations, each describing the policy's preferences for a regulation
  regulations: [PolicyRegulation!]

  # A list of PolicyCategories, each describing the policy's overrides for a policy category
  policyCategories: [PolicyCategory]!

  # When the policy version was created
  createdAt: DateTime!

  # The UUID ref of the user who created this policy version
  createdBy: UUID
}

# A Note is a String between 1 and 2000 characters in length
scalar Note

# A set a overrides for a finding in a policy
type PolicyFinding {
  # Identifier for the finding check affected by these overrides
  checkId: FindingCheckID!

  # Whether the finding should be shown in reports, and used for derived data like scores
  hidden: Boolean!

  # The policy category this finding should be sorted into if affected
  policyCategory: PolicyCategoryInteger!

  # The CVSS score for this finding
  cvss: CVSSScore

  # The CVSS vector for this finding
  cvssVector: CVSSVector

  # The impactType this finding would have, if the finding were found affected in a report
  impactType: FindingImpactTypeEnum!
}

# Unique finding check identity (NB: these IDs are still being normalized and will likely change in near future).
enum FindingCheckID {
  #
  unprotected_context_registered_broadcast_receivers

  #
  unprotected_manifest_broadcast_receivers

  #
  exported_components

  #
  app_transport_security

  #
  ipa_ats_exemptions_requiring_review

  #
  apk_insecure_network_config

  #
  apk_network_config_exceptions

  #
  libraries_arc

  #
  libraries_ssp

  #
  apk_libraries_aslr

  #
  libraries_aslr

  #
  ipa_libraries_aslr

  #
  apk_hardcoded_keys

  #
  apk_vpn_always_on_not_available

  #
  apk_uses_vpn_permission

  #
  libpng_cve

  #
  nanopb_cve

  #
  joda_cve

  #
  android_ssl_vuln

  #
  android_janus_vuln

  #
  android_janus_warn

  #
  android_minimum_sdk

  #
  android_debuggable_webviews

  #
  android_static_iv

  #
  android_target_sdk_min

  #
  apk_dangerous_permissions

  #
  apk_permissions

  #
  app_sbom

  #
  javascript_interface_check

  #
  kotlin_debug_lib

  #
  ipa_dangerous_entitlements

  #
  ipa_insecure_constants

  #
  ipa_get_task_allow

  #
  ipa_uiwebview_asb

  #
  ipa_debug_symbols_dwarf_stripped

  #
  ipa_ftp_libs

  #
  apk_ftp_libs

  #
  ipa_url_hijacking

  #
  ipa_nsurlconnection_allows_all

  #
  hardcoded_api_keys

  #
  fragment_injection

  #
  on_received_ssl_error_proceed

  #
  apk_debug_symbols

  #
  apk_insecure_constants

  #
  apk_deeplinks

  #
  ipa_debug_symbols_stripped

  #
  libjpeg_turbo

  #
  obfuscation_check

  #
  decompile_apk_check

  #
  decode_apk_check

  #
  get_native_methods

  #
  debug_flag_check

  #
  allow_backup_check

  #
  master_key_check

  #
  certificate_validity_check

  #
  get_app_files

  #
  keysize_check

  #
  url_listing

  #
  sqlcipher_key_leakage_check

  #
  potential_sqlcipher_key_leakage_check

  #
  get_reflection_code

  #
  okhttp

  #
  heartbleed_check

  #
  change_cipher_spec_check

  #
  local_auth_check

  #
  ipa_metadata

  #
  entitlements

  #
  ipa_keyboard

  #
  ipa_improper_data_protection_entitlement

  #
  ipa_improper_data_protection_entitlement_creds

  #
  ipa_url_schemes

  #
  all_android_components

  #
  runs_root_command

  #
  hardcoded_passwords

  #
  apk_hardcoded_secrets

  #
  apk_certificate_pinning

  #
  background_modes

  #
  application_behaviors

  #
  address_reference_counting_check

  #
  stack_smashing_protection_check

  #
  address_space_layout_rand_check

  #
  application_overprivileged_check

  #
  dynamic_code_loading_check

  #
  secure_random_check

  #
  apk_blocker_apptentive

  #
  apk_blocker_segment

  #
  ipa_debug_symbols_files

  #
  play_services_basement

  #
  apk_in_app_updates

  #
  apk_play_store_updates

  #
  apk_leaked_data_sdcard

  #
  afnetworking

  #
  afnetworking_detected

  #
  api_cors

  #
  uipasteboard_expiry

  #
  uipasteboard_handoff

  #
  nscoding

  #
  ipa_leaked_data_in_cache_db

  #
  jailbreak_detection

  #
  asl

  #
  oslog

  #
  geoip

  #
  snoop_network_hosts

  #
  sdcard_file_list

  #
  apk_info

  #
  world_readable_files_check

  #
  runs_root_command_check

  #
  arbitrary_code_execution_observed

  #
  arbitrary_code_execution_probable

  #
  directory_traversal_content_providers

  #
  path_traversal

  #
  sql_injection

  #
  behavioral_events

  #
  sms_communications

  #
  ipa_broken_ssl

  #
  automation_info

  #
  ipa_dynamic_log

  #
  ios_keychain

  #
  ipa_sensitive_data_keychain_username

  #
  ipa_sensitive_data_keychain_password

  #
  ipa_sensitive_data_keychain_custom

  #
  ipa_sensitive_data_keychain_other

  #
  interaction

  #
  sqlite

  #
  apk_sqlite

  #
  apk_sqlcipher

  #
  network

  #
  cert

  #
  frameworks

  #
  ipa_network_data_flows

  #
  ipa_crypto_data_flows

  #
  uiwebview_insecure_load

  #
  uiwebview_sop_bypass

  #
  ios_keyboard

  #
  ipa_certificate_pinning

  #
  ipa_urlsession_cert_validation

  #
  ios_preferences

  #
  secure_drbg

  #
  ios_iv_hardcoded

  #
  ios_iv_null

  #
  ios_iv_reuse

  #
  leaked_data_in_files_custom

  #
  leaked_data_in_files_username

  #
  leaked_data_in_files_password

  #
  leaked_data_in_files_email

  #
  leaked_data_in_files_firstname

  #
  leaked_data_in_files_lastname

  #
  leaked_data_in_files_name

  #
  leaked_data_in_files_phonenumber

  #
  leaked_data_in_files_zipcode

  #
  leaked_data_in_files_gpslatitude

  #
  leaked_data_in_files_gpslongitude

  #
  leaked_data_in_files_imei

  #
  leaked_data_in_files_android_id

  #
  leaked_data_in_files_serial

  #
  leaked_data_in_files_mac

  #
  leaked_data_in_files_wifi_ip

  #
  leaked_data_in_files_build_fingerprint

  #
  leaked_data_in_files_localwifimac

  #
  leaked_data_in_files_surrounding_wifimac

  #
  leaked_data_in_files_dns1

  #
  leaked_data_in_files_dns2

  #
  leaked_data_in_files_surrounding_wifi_network_ssid

  #
  leaked_data_in_files_surrounding_wifi_network_bssid

  #
  leaked_data_in_files_bluetooth_mac

  #
  leaked_data_in_files_wifi_mac

  #
  leaked_data_in_files_provision_revision

  #
  ipa_leaked_data_in_files_custom

  #
  ipa_leaked_data_in_files_username

  #
  ipa_leaked_data_in_files_password

  #
  ipa_leaked_data_in_files_email

  #
  ipa_leaked_data_in_files_firstname

  #
  ipa_leaked_data_in_files_lastname

  #
  ipa_leaked_data_in_files_name

  #
  ipa_leaked_data_in_files_phonenumber

  #
  ipa_leaked_data_in_files_zipcode

  #
  ipa_leaked_data_in_files_gpslatitude

  #
  ipa_leaked_data_in_files_gpslongitude

  #
  ipa_leaked_data_in_files_idfv

  #
  ipa_leaked_data_in_files_adid

  #
  ipa_leaked_data_in_files_localwifimac

  #
  ipa_leaked_data_in_files_surrounding_wifimac

  #
  leaked_memdump_data_custom

  #
  leaked_memdump_data_username

  #
  leaked_memdump_data_password

  #
  leaked_memdump_data_email

  #
  leaked_memdump_data_firstname

  #
  leaked_memdump_data_lastname

  #
  leaked_memdump_data_name

  #
  leaked_memdump_data_phonenumber

  #
  leaked_memdump_data_zipcode

  #
  leaked_memdump_data_gpslatitude

  #
  leaked_memdump_data_gpslongitude

  #
  leaked_memdump_data_imei

  #
  leaked_memdump_data_android_id

  #
  leaked_memdump_data_serial

  #
  leaked_memdump_data_mac

  #
  leaked_memdump_data_wifi_ip

  #
  leaked_memdump_data_build_fingerprint

  #
  leaked_memdump_data_localwifimac

  #
  leaked_memdump_data_surrounding_wifimac

  #
  leaked_memdump_data_dns1

  #
  leaked_memdump_data_dns2

  #
  leaked_memdump_data_surrounding_wifi_network_ssid

  #
  leaked_memdump_data_surrounding_wifi_network_bssid

  #
  leaked_memdump_data_bluetooth_mac

  #
  leaked_memdump_data_wifi_mac

  #
  leaked_memdump_data_provision_revision

  #
  ipa_leaked_memdump_data_custom

  #
  ipa_leaked_memdump_data_username

  #
  ipa_leaked_memdump_data_password

  #
  ipa_leaked_memdump_data_email

  #
  ipa_leaked_memdump_data_firstname

  #
  ipa_leaked_memdump_data_lastname

  #
  ipa_leaked_memdump_data_name

  #
  ipa_leaked_memdump_data_phonenumber

  #
  ipa_leaked_memdump_data_zipcode

  #
  ipa_leaked_memdump_data_gpslatitude

  #
  ipa_leaked_memdump_data_gpslongitude

  #
  ipa_leaked_memdump_data_idfv

  #
  ipa_leaked_memdump_data_adid

  #
  ipa_leaked_memdump_data_localwifimac

  #
  ipa_leaked_memdump_data_surrounding_wifimac

  #
  leaked_logcat_data_username

  #
  leaked_logcat_data_password

  #
  leaked_logcat_data_email

  #
  leaked_logcat_data_firstname

  #
  leaked_logcat_data_lastname

  #
  leaked_logcat_data_name

  #
  leaked_logcat_data_phonenumber

  #
  leaked_logcat_data_zipcode

  #
  leaked_logcat_data_gpslatitude

  #
  leaked_logcat_data_gpslongitude

  #
  leaked_logcat_data_imei

  #
  leaked_logcat_data_android_id

  #
  leaked_logcat_data_serial

  #
  leaked_logcat_data_mac

  #
  leaked_logcat_data_wifi_ip

  #
  leaked_logcat_data_build_fingerprint

  #
  leaked_logcat_data_localwifimac

  #
  leaked_logcat_data_surrounding_wifimac

  #
  leaked_logcat_data_dns1

  #
  leaked_logcat_data_dns2

  #
  leaked_logcat_data_surrounding_wifi_network_ssid

  #
  leaked_logcat_data_surrounding_wifi_network_bssid

  #
  leaked_logcat_data_bluetooth_mac

  #
  leaked_logcat_data_wifi_mac

  #
  leaked_logcat_data_provision_revision

  #
  leaked_logcat_data_custom

  #
  leaked_asl_data_custom

  #
  leaked_asl_data_username

  #
  leaked_asl_data_password

  #
  leaked_asl_data_email

  #
  leaked_asl_data_firstname

  #
  leaked_asl_data_lastname

  #
  leaked_asl_data_name

  #
  leaked_asl_data_phonenumber

  #
  leaked_asl_data_zipcode

  #
  leaked_asl_data_gpslatitude

  #
  leaked_asl_data_gpslongitude

  #
  leaked_asl_data_idfv

  #
  leaked_asl_data_adid

  #
  leaked_asl_data_localwifimac

  #
  leaked_asl_data_surrounding_wifimac

  #
  sensitive_data_http_username

  #
  sensitive_data_http_password

  #
  sensitive_data_http_email

  #
  sensitive_data_http_firstname

  #
  sensitive_data_http_lastname

  #
  sensitive_data_http_name

  #
  sensitive_data_http_phonenumber

  #
  sensitive_data_http_zipcode

  #
  sensitive_data_http_gpslatitude

  #
  sensitive_data_http_gpslongitude

  #
  sensitive_data_http_imei

  #
  sensitive_data_http_android_id

  #
  sensitive_data_http_serial

  #
  sensitive_data_http_mac

  #
  sensitive_data_http_wifi_ip

  #
  sensitive_data_http_build_fingerprint

  #
  sensitive_data_http_localwifimac

  #
  sensitive_data_http_surrounding_wifimac

  #
  sensitive_data_http_dns1

  #
  sensitive_data_http_dns2

  #
  sensitive_data_http_surrounding_wifi_network_ssid

  #
  sensitive_data_http_surrounding_wifi_network_bssid

  #
  sensitive_data_http_bluetooth_mac

  #
  sensitive_data_http_wifi_mac

  #
  sensitive_data_http_provision_revision

  #
  sensitive_data_http_custom

  #
  ipa_sensitive_data_http_username

  #
  ipa_sensitive_data_http_password

  #
  ipa_sensitive_data_http_email

  #
  ipa_sensitive_data_http_firstname

  #
  ipa_sensitive_data_http_lastname

  #
  ipa_sensitive_data_http_phonenumber

  #
  ipa_sensitive_data_http_zipcode

  #
  ipa_sensitive_data_http_gpslatitude

  #
  ipa_sensitive_data_http_gpslongitude

  #
  ipa_sensitive_data_http_idfv

  #
  ipa_sensitive_data_http_adid

  #
  ipa_sensitive_data_http_localwifimac

  #
  ipa_sensitive_data_http_surrounding_wifimac

  #
  ipa_sensitive_data_http_deviceinfo

  #
  ipa_sensitive_data_http_custom

  #
  world_writable_files_check

  #
  remote_code_execution

  #
  api_discovery

  #
  crypto_methods

  #
  uses_http

  #
  cookie_without_httponly_flag

  #
  cookie_without_secure_flag

  #
  zip_file_in_transit_check

  #
  ipa_zip_file_in_transit_check

  #
  zip_file_in_transit_check_https

  #
  ipa_zip_file_in_transit_check_https

  #
  zip_file_in_transit_check_broken_ssl

  #
  hostname_verification

  #
  certificate_validation

  #
  broken_ssl

  #
  sensitive_data_cert_validation

  #
  ipa_sensitive_data_cert_validation

  #
  sensitive_data_flow

  #
  ipa_sensitive_data_flow

  #
  ipa_device_lock

  #
  apk_data_safety_personal_info_collected

  #
  apk_data_safety_device_or_other_ids_collected

  #
  apk_data_safety_location_collected

  #
  apk_data_safety_personal_info_shared

  #
  apk_data_safety_device_or_other_ids_shared

  #
  apk_data_safety_location_shared

  #
  ipa_sensitive_data_weak_crypto

  #
  ipa_weak_crypto_methods

  #
  apk_weak_crypto_methods

  #
  apk_iv_reuse

  #
  apk_iv_null

  #
  apk_application_servers

  #
  ipa_application_servers

  #
  opened_urls

  #
  leaked_data_in_opened_urls

  #
  privacy_policy

  #
  apk_textfield_autocorrect

  #
  ipa_textfield_autocorrect

  #
  apk_ui_leakage

  #
  ipa_ui_leakage

  #
  ipa_hardcoded_keys_read_observed

  #
  apk_hardware_backed_keys

  #
  ipa_hardware_backed_keys

  #
  android_key_reuse

  #
  ios_key_reuse

  #
  ipa_weak_crypto_hashing_algorithms

  #
  apk_weak_crypto_hashing_algorithms

  #
  ipa_weak_crypto_encryption_algorithms

  #
  apk_weak_crypto_encryption_algorithms

  #
  ipa_weak_crypto_encryption_modes

  #
  apk_weak_crypto_encryption_modes

  #
  ipa_weak_crypto_insufficient_rounds

  #
  apk_weak_crypto_insufficient_rounds

  #
  api_hsts

  #
  unsigned_jwt

  #
  serialized_objects

  #
  ipa_jb_detection_rasp

  #
  android_root_detection_rasp

  #
  writable_executable_files_private_check

  #
  writable_executable_files_check

  #
  api_excessive_data_exposure

  #
  api_authentication

  #
  api_resource_consumption

  #
  api_resource_misconfiguration

  #
  NIAP_FCS_RBG_EXT_1_1

  #
  NIAP_FCS_CKM_EXT_1_1

  #
  NIAP_FCS_STO_EXT_1_1

  #
  NIAP_FDP_DEC_EXT_1_1

  #
  NIAP_FDP_DEC_EXT_1_2

  #
  NIAP_FDP_NET_EXT_1_1

  #
  NIAP_FDP_DAR_EXT_1_1

  #
  NIAP_FMT_MEC_EXT_1_1

  #
  NIAP_FMT_CFG_EXT_1_1

  #
  NIAP_FMT_CFG_EXT_1_2

  #
  NIAP_FMT_SMF_1_1

  #
  NIAP_FPR_ANO_EXT_1_1

  #
  NIAP_FPT_API_EXT_1_1

  #
  NIAP_FPT_AEX_EXT_1_1

  #
  NIAP_FPT_AEX_EXT_1_2

  #
  NIAP_FPT_AEX_EXT_1_3

  #
  NIAP_FPT_AEX_EXT_1_4

  #
  NIAP_FPT_AEX_EXT_1_5

  #
  NIAP_FPT_TUD_EXT_1_1

  #
  NIAP_FPT_TUD_EXT_1_2

  #
  NIAP_FPT_TUD_EXT_1_3

  #
  NIAP_FPT_TUD_EXT_1_4

  #
  NIAP_FPT_TUD_EXT_1_5

  #
  NIAP_FPT_LIB_EXT_1_1

  #
  NIAP_FPT_IDV_EXT_1_1

  #
  NIAP_FTP_DIT_EXT_1_1

  #
  NIAP_FCS_CKM_1_1_2_

  #
  NIAP_FCS_RBG_EXT_2_1

  #
  NIAP_FCS_RBG_EXT_2_2

  #
  NIAP_FCS_CKM_1_1_1_

  #
  NIAP_FCS_CKM_1_1_3_

  #
  NIAP_FCS_CKM_1_2_3_

  #
  NIAP_FCS_CKM_2_1

  #
  NIAP_FCS_COP_1_1_1_

  #
  NIAP_FCS_COP_1_1_2_

  #
  NIAP_FCS_COP_1_1_3_

  #
  NIAP_FCS_COP_1_1_4_

  #
  NIAP_FCS_HTTPS_EXT_1_1

  #
  NIAP_FCS_HTTPS_EXT_1_2

  #
  NIAP_FCS_HTTPS_EXT_1_3

  #
  NIAP_FIA_X509_EXT_1_1

  #
  NIAP_FIA_X509_EXT_1_2

  #
  NIAP_FIA_X509_EXT_2_1

  #
  NIAP_FIA_X509_EXT_2_2

  #
  NIAP_FPT_TUD_EXT_2_1

  #
  NIAP_FPT_TUD_EXT_2_2

  #
  NIAP_FPT_API_EXT_2_1

  #
  NIAP_ALC_CMC_1_1C

  #
  NIAP_ATE_IND_1_2E

  #
  NIAP_AVA_VAN_1_1C

  #
  NIAP_AVA_VAN_1_2E

  #
  IOXT_AA1

  #
  IOXT_AA2

  #
  IOXT_AA3

  #
  IOXT_AA4

  #
  IOXT_VDP1

  #
  IOXT_VDP2

  #
  IOXT_VDP3

  #
  IOXT_VDP4

  #
  IOXT_VDP5

  #
  IOXT_SE1_1

  #
  IOXT_SE1_2

  #
  IOXT_UP1

  #
  IOXT_UP2_1

  #
  IOXT_UP2_2

  #
  IOXT_UP103

  #
  IOXT_UP104

  #
  IOXT_UP105

  #
  IOXT_UP106

  #
  IOXT_UP107

  #
  IOXT_PC1

  #
  IOXT_PC2

  #
  IOXT_PC103

  #
  IOXT_PC104__VPN

  #
  IOXT_SD1

  #
  IOXT_SD109

  #
  IOXT_SD110

  #
  IOXT_SD111

  #
  IOXT_SD112

  #
  IOXT_SD113

  #
  IOXT_SD114

  #
  IOXT_SD115

  #
  IOXT_SI1_1

  #
  IOXT_SI1_2

  #
  IOXT_SI1_3

  #
  IOXT_SI1_4

  #
  IOXT_SI2_1

  #
  IOXT_SI2_2

  #
  IOXT_SI2_3

  #
  IOXT_SI110

  #
  IOXT_SI111

  #
  IOXT_SI112

  #
  IOXT_SI113

  #
  IOXT_SI114__VPN

  #
  IOXT_SI115__VPN

  #
  IOXT_SI116__VPN

  #
  IOXT_VS1

  #
  IOXT_VS2

  #
  IOXT_VS3

  #
  IOXT_VS4
}

# PolicyCategoryIntegers are integers in the range 1-3
scalar PolicyCategoryInteger

# CVSS (Common Vulnerability Scoring System) scores are in the range 0-10, with 1 decimal place, and indicate the severity of a vulnerability relative to other vulnerabilities
scalar CVSSScore

# CVSS vectors are compressed textual representations of the values used to derive the CVSS scores
scalar CVSSVector

# Finding impact
enum FindingImpactTypeEnum {
  #
  artifact

  #
  indeterminate

  #
  pass

  #
  info

  #
  warn

  #
  low

  #
  medium

  #
  high

  #
  critical
}

# Preferences for a regulation in a policy
type PolicyRegulation {
  # Identifier for the regulation these preferences are for
  regulation: RegulatoryTypeEnum!

  # Whether this regulation is available for targeted entities
  enabled: Boolean!
}

# Regulatory type
enum RegulatoryTypeEnum {
  #
  cwe

  #
  niap

  #
  ioxt

  #
  fisma_low

  #
  fisma_med

  #
  owasp

  #
  gdpr

  #
  ffiec

  #
  pci

  #
  hipaa

  #
  ccpa

  #
  google_caq

  #
  apple_guidelines

  #
  cwe_top_25
}

# Describes overrides for a policy category
type PolicyCategory {
  # The policy category these overrides apply to
  policyCategory: PolicyCategoryInteger!

  # A label for the policy category
  label: String!

  # A short description for the policy category
  description: EntityDescription

  # A color used by UI referencing this category
  color: HexColor!
}

# An EntityDescription is a String between 1 and 100 characters in length
scalar EntityDescription

# HexColors are 6-digit hex color codes
scalar HexColor

#
type NamedAnalysisConfigTemplate {
  # Unique (per group) name string representing a specific configuration which can be reused as a template
  name: String!

  # Config template integer id field
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  id: String!

  # Saved analysis config entry data
  entry: AnalysisConfigEntry!
}

#
type AnalysisConfigEntry {
  #
  actions: AnalysisConfigActionsEntry

  # List all configured sensitive data types (specify searchStrings, toggle isSensitive).
  searchData: [AnalysisConfigSearchDataEntry!]

  # List all specified custom search terms and their associated searchStrings.
  searchTerms: [AnalysisConfigSearchTermEntry!]

  # API test configuration.
  api: AnalysisConfigApiEntry

  # View appium runner config
  appium: AnalysisConfigAppiumRunnerEntry

  # View XCTest runner config (ios-specific)
  xctest: AnalysisConfigXcTestRunnerEntry

  # View Espresso runner configuration (android-specific)
  espresso: AnalysisConfigEspressoRunnerEntry

  # Corresponds to legacy automation_js_script field of dynamic config.
  # e.g. "onPermissionRequest(function (request) {  ..."
  jsScript: String

  # Corresponds to legacy dsl_script field of dynamic config.
  # e.g. "var target = UIATarget.localTarget(); ..."
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  dslScript: String

  #
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  dslScriptFilename: String

  # View resigning configuration.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  resigning: AnalysisConfigResigningEntry

  # This configuration puts dynamic analysis into an experimental new "debug" mode where it will fail fast upon encountering an error.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  failfast: Boolean!
}

#
type AnalysisConfigActionsEntry {
  #
  find: [String!]!

  #
  avoid: [String!]!
}

#
type AnalysisConfigSearchDataEntry {
  #
  key: String!

  #
  value: String!

  #
  searchStrings: [String!]!

  #
  nonSensitive: Boolean!
}

#
type AnalysisConfigSearchTermEntry {
  #
  name: String!

  #
  value: String!

  #
  searchStrings: [String!]!
}

# API testing configuration.
type AnalysisConfigApiEntry {
  # Explicit list of URLs for which active API testing has been enabled.
  activeTestingList: [String!]!
}

#
type AnalysisConfigAppiumRunnerEntry {
  # Filename representive of appium runner, e.g. "my-appium-test.py"
  runnerFilename: String

  # Either node, python or python3
  interpreter: AppiumInterpreter

  # Optional command to run before analysis
  setupCommand: String

  # The original filename of the uploaded archive
  archiveFilename: String

  # Full URL to the remote resource
  code: String

  # Additional arguments to pass to the appium script
  args: [String!]

  # Environment variables
  env: [AppiumEnvVar!]
}

#
enum AppiumInterpreter {
  #
  python

  #
  python3

  #
  node
}

#
type AppiumEnvVar {
  # The identifier for the environment variable
  identifier: String!

  # The value for the environment variable
  value: String!
}

#
type AnalysisConfigXcTestRunnerEntry {
  # XCTest function name to target, e.g. "testSomeAppLogin"
  functionName: String

  # Filename representive of XCTest runner, e.g. "com.someapp.client-Runner.ipa"
  runnerFilename: String
}

#
type AnalysisConfigEspressoRunnerEntry {
  # The package name of the espresso test runner
  runnerPackagename: String!

  # Optional array of test runner class names
  testClasses: [String!]

  # Filename of the Espresso test runner file, e.g. "com.someapp.client-Runner.apk"
  runnerFilename: String
}

#
type AnalysisConfigResigningEntry {
  #
  disable: Boolean!
}

#
scalar JSON

#
type Setting {
  #
  key: String!

  #
  value: JSON
}

#
type AutoBuild implements Build {
  # Unique build identifier.
  ref: UUID!

  # Reference to associated access control group.
  groupRef: UUID!

  # SHA-256 hex digest of build binary file hash.
  digest: String!

  # Platform target (ios or android).
  platformType: PlatformEnum!

  # Package name (android) or bundle id string (ios).
  packageKey: String!

  # Key used to download build from appstore, if any.
  appstoreApplicationKey: String

  # When the build record was first created.
  createdAt: DateTime!

  # When the build was uploaded.
  uploadedAt: DateTime

  # UUID ref of user who uploaded.
  uploadedBy: UUID

  # Application title, as extracted from build metadata, by default.
  #
  # This field represents the user-managed version sort key associated with the build. Its value defaults to the version extracted from build metadata. Its value should be a semver-compliant string -- if not, its value will be pointwise-sorted by integer then string components.
  title: String

  # Application version, as extracted from build metadata, by default.
  #
  # This field represents the user-managed title associated with the build. Its value defaults to the title extracted from build metadata.
  version: String

  # URL to icon file, as extracted from build metadata.
  iconURL: String

  # True if metadata extraction has been completed on uploaded build binary.
  isAnalyzed: Boolean!

  # True if build was downloaded from a public appstore. Otherwise, the build was provided directly.
  isAppstoreDownload: Boolean!
}

# Application build -- specific "version" of an application package, installable on a device of associated platform
interface Build {
  # SHA-256 hex digest of build binary file hash
  digest: String

  # Icon URL
  iconURL: String

  # Version specified in build metadata
  version: String
}

#
type AutoAssessment implements Assessment {
  # Raw JSON
  _raw(path: String!): JSON

  # Unique identifier for an assessment
  ref: UUID!

  # Platform targeted by assessment (ios or android)
  platformType: PlatformEnum!

  # Package name (android) or bundle id string (iOS)
  packageKey: String!

  # Analysis task identity
  taskId: ID!

  # Date when assessment record was created.
  createdAt: DateTime!

  # Date when all analysis tasks have completed successfully and results became available.
  # This value will be null if any required analysis has not yet completed.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  allAnalysisAvailableAt: DateTime

  # Reference to the user who created the assessment.
  # This value will be null for any system-generated assessments which are automatically created due to monitoring.
  #
  # - TODO
  #   - deprecate and add a creator namespace field linking user
  creatingUserRef: UUID

  # Title of the app package being assessed, according to the metadata extracted from the build binary.
  title: String @deprecated(reason: "Use the build.title field")

  # Icon URL for the assessment
  iconURL: String @deprecated(reason: "Use the application iconURL field")

  # True if build was downloaded from a public appstore. Otherwise, the build was provided directly.
  isAppstoreDownload: Boolean!

  # The assessment's analysis tasks
  analysis: AutoAssessmentAnalysis!

  # Security score for assessment, generated from findings static and dynamic findings (when both are available).
  #
  # By default this score takes into consideration all vulnerabilities (including any edits/adjustments to assessments).
  score: Float

  # Assessment report, potentially adjusted with customer edits
  report: AssessmentReport

  # Compliance report
  evaluation(
    type: RegulatoryComplianceEvaluationType!
  ): RegulatoryComplianceEvaluation

  # Assessment report generated by NowSecure
  #
  # Note: the plan is to extend report field to take a "revision" parameter,
  # allowing any given report revision to be looked up. At which point this field
  # will be deprecated like so: `@deprecated(reason: "use baseReport: report(revision: 0))"`.
  baseReport: AssessmentReport

  # Single context data found by a finding,
  findingContext(
    checkId: FindingCheckID!
    _analysisInputs: JSON
    _useSampleInput: String
  ): FindingContext
    @deprecated(
      reason: "Use report.finding.context, evaluation.finding.context, etc."
    )

  # Context data for all findings within assessment.
  findingContexts(
    evaluationType: RegulatoryComplianceEvaluationType
    _analysisInputs: JSON
    _useSampleInput: String
  ): [FindingContext!]!
    @deprecated(
      reason: "Use report.findings.context, evaluation.findings.context etc."
    )

  # Reference to associated application.
  #
  # - TODO
  #   - deprecate and add an application namespace
  applicationRef: UUID!

  # Appstore key used to download assessment binary from appstore
  appstoreApplicationKey: String

  # Reference to associated group
  #
  # - TODO
  #   - @deprecated(reason: "Use group.ref")
  groupRef: UUID!

  # Analysis group entity associated with this assessment's app
  group: AutoGroup!

  # Hash digest for build binary this assessment was run on.
  buildDigest: String

  # Reference to the build this assessment was run against.
  buildRef: String

  # Build entity this assessment was run against.
  build: AutoBuild

  # Custom JSON config specified for static and/or dynamic analysis engines.
  config: JSON

  # The configuration level used for this assessment.
  analysisConfigLevel: AnalysisConfigLevel

  # Whether all analysis was created using our standard, baseline configuration.
  hasBaselineConfig: Boolean!

  # Error code associated with assessment.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  errorCode: String

  # Version string uniquely identifying a specific application build.
  #
  # TODO: define a GQL type for "SemiverString"?
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  buildVersion: String!

  # Version string as defined by developer and packaged into build binary.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  packageVersion: ID

  # Release version as reported by appstore at time of download (often but not always identical to package version).
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  releaseVersion: String

  # Whether this assessment has been marked as a favorite.
  favorite: Boolean!

  #
  adjustedIssueInputs: JSON @deprecated(reason: "Use report.findings.")

  #
  baseIssueInputs: JSON @deprecated(reason: "Use baseReport.findings.")

  #
  cancelled: Boolean! @deprecated(reason: "Use isCancelled.")

  #
  created: DateTime! @deprecated(reason: "Use createdAt.")

  #
  id: ID! @deprecated(reason: "Use ref.")

  #
  package: String! @deprecated(reason: "Use packageKey.")

  #
  platform: PlatformEnum! @deprecated(reason: "Use platformType.")

  #
  storeKey: String! @deprecated(reason: "use appstoreApplicationKey.")

  #
  task: ID! @deprecated(reason: "Use taskId.")

  # List distinct countries with which network traffic was detected.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  networkConnectionCountries: [Country!]

  #
  workflow: AssessmentWorkflow

  # Flag to indicate when assessment has been run in experimental new debug mode to fail fast dynamic analysis.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  isDebugMode: Boolean!

  # The PolicyVersion saved against this assessment.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  policyVersion: PolicyVersion

  # The Policy associated with the PolicyVersion saved against this assessment.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  policy: Policy

  # A compliance report with regards to the given compliance report catalog.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  complianceReport(catalog: ComplianceReportCatalog!): ComplianceReport
}

#
interface Assessment {
  # Platform targeted by assessment
  platformType: PlatformEnum!

  # Package name (android) or bundle id string (iOS)
  packageKey: String!

  # When the assessment was created
  createdAt: DateTime!

  # App title, as extracted from assessed build
  title: String @deprecated(reason: "Use the application title field")

  # Icon url, as extracted from assessed build (possibly base64-encoded data: url)
  iconURL: String @deprecated(reason: "Use the application iconURL field")

  # Compliance report specific
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  evaluation(
    # Compliance provider type for evaluation
    type: RegulatoryComplianceEvaluationType!
  ): RegulatoryComplianceEvaluation

  # Whether or not build was downloaded directly from a public appstore.
  isAppstoreDownload: Boolean!

  # Whether all analysis was created using our standard, baseline configuration.
  hasBaselineConfig: Boolean!

  # Security score for assessment, generated from findings static and dynamic findings (when both are available).
  score: Float

  # Error code associated with assessment.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  errorCode: String

  # Version string uniquely identifying a specific application build.
  #
  # TODO: define a GQL type for "SemiverString"?
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  buildVersion: String!

  # Version string as defined by developer and packaged into build binary.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  packageVersion: ID

  # Release version as reported by appstore at time of download (often but not always identical to package version).
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  releaseVersion: String

  # List distinct countries with which network traffic was detected.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  networkConnectionCountries: [Country!]
}

#
enum RegulatoryComplianceEvaluationType {
  # National Information Assurance Partnership
  NIAP

  # ioXt Alliance
  IOXT
}

#
type RegulatoryComplianceEvaluation {
  # Date when the all required analysis results became available.
  createdAt: DateTime!

  #
  providerType: RegulatoryComplianceEvaluationType!

  #
  findings: [Finding!]!

  # List of assertion states, at most one per NIAP requirement.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  assertions: [NiapRequirementAssertion!]

  # Whether an evaluator has began the evaluation
  evaluationStarted: Boolean!
}

# This represents a specific instance of a finding, associated with a specific assessment.
type Finding {
  #
  key: String!

  # Identifier of check that was run for this finding.
  checkId: FindingCheckID!

  # Check that was run for this finding.
  check: FindingCheck!

  # Whether or not this finding was affected (null if indeterminate).
  affected: Boolean

  # What status a finding is in (only specifically relevant for compliance finding, for now)
  status: EvaluationRequirementStatusEnum

  # Calculated CVSS score as per [Common Vulnerability Scoring System](https://www.first.org/cvss/specification-document)
  cvss: Float

  # CVSS component vector associated with finding issue.
  cvssVector: String

  # Enumerated categorization of potential impact associated with finding.
  impactType: FindingImpactTypeEnum!

  # Severity of vulnerability, if found to be affected.
  severity: VulnerabilitySeverityCategoryEnum

  # Whether or not this findings is hidden.
  hidden: Boolean

  # A note added to this finding.
  note: String

  # A short piece of summary text added to this finding.
  shortRemediation: String

  #
  regulations: [RegulatoryRelation!]

  # A list of relations that associate this finding to a control within a compliance report catalog.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  complianceReportRelations(
    catalog: ComplianceReportCatalog
  ): [ComplianceReportRelation!]

  #
  title: String!

  #
  summary: String

  #
  description: String

  #
  category: String

  # Policy categorization for this finding.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  policyCategory: PolicyCategory

  #
  kind: String!

  # Markdown content representing recommended remediation.
  recommendation: String

  # A boolean indicating whether this finding has any context to show.
  #
  # Note: Not supported within the intel namespace.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  hasContext: Boolean!

  # Finding context data, including a potentially recursive declarative schema defining tabular fields, including formatting hints for rendering.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  context: FindingContext

  # List of fields that have been adjusted.
  adjustments: [FindingAdjustmentEnum!]!

  # Integer unique vulnerability id.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  uniqueVulnerabilityId: Int

  # A list of metadata objects describing supporting files uploaded in association with this finding
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  findingAttachments: [FindingAttachment!]
}

# Finding "check" represents a specific logical test which takes place within available analysis.
# This subset of available analysis data represents a specific conceptual "finding of fact" being "checked" for.
type FindingCheck {
  #
  id: FindingCheckID!

  #
  legacyFindingKey: String
    @deprecated(
      reason: "use property id field (~ same values but with normalized case/punctuation)"
    )

  # Specific analysis type associated with findings check.
  analysisType: AnalysisType!

  # Categorization enum of finding check.
  category: FindingCategoryEnum!

  # String title distinguishing a given finding from others.
  title: String!

  # Markdown content describing the finding in more detail.
  description: String

  # Yields a string suitable for representing a given finding by name for reporting purposes.
  displayName: String!

  # Yields a string suitable for representing a given finding identifier key for reporting purposes.
  displayKey: String!

  # Specific platform associated with the finding, if any.
  platformType: PlatformEnum

  # Issue definition associated with the finding, if any.
  issue: FindingIssue

  # Regulatory compliance evaluation instructions (only applicable to regulatory compliance findings)
  compliance: RegulatoryComplianceEvaluationInstructions

  # Describes how to render the context metadata, if the finding has context.
  context: FindingContextMetadata

  # Determines whether or not this finding should be considered deprecated (i.e. suppressed in reporting).
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  deprecated: Boolean
}

#
enum AnalysisType {
  #
  dynamic

  #
  static

  #
  compliance
}

# Finding category
enum FindingCategoryEnum {
  #
  code

  #
  network

  #
  permissions

  #
  artifact

  #
  storage

  #
  api

  #
  ipc

  #
  fs

  #
  Privacy
}

# A finding "issue" represents the metadata surrounding well-defined potential security issue we may check for.
#
# An issue with an associated cvss vector and score represents a potential "vulnerability", as considered by NowSecure.
type FindingIssue {
  # Issue title string naming the *potential* vulnerability associated with a given finding.
  title: String!

  # Markdown content describing the issue in more detail.
  description(platform: PlatformEnum): String!

  # Markdown content to display when application is not found to be affected by issue.
  passingContent(platform: PlatformEnum): String

  # Attempts to characterize the general impact this vulnerability could have in the wild.
  impactSummary(platform: PlatformEnum): String

  # Steps to reproduce
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  stepsToReproduce(platform: PlatformEnum): String

  # Markdown recommendation for remediation, optionally by platform.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  recommendation(platform: PlatformEnum): String

  # Code samples demonstrating issue.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  codeSamples(platform: PlatformEnum): [IssueCodeSample!]

  # Links to additional guidance related to issue.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  guidanceLinks(platform: PlatformEnum): [IssueGuidanceLink!]

  # Calculated CVSS score as per [Common Vulnerability Scoring System](https://www.first.org/cvss/specification-document).
  cvss: Float

  # CVSS component vector associated with finding issue.
  cvssVector: String

  # [CVE](https://cve.mitre.org/) identifier associated with potential vulnerability.
  cve: String

  #
  category: VulnerabilityCategoryEnum

  # Whether or not a given issue should only be considered a warning.
  warn: Boolean!

  #
  severity: VulnerabilitySeverityCategoryEnum

  #
  complexity: AttackComplexityCategoryEnum

  #
  privileges: AttackPrivilegesCategoryEnum

  #
  vector: AttackVectorCategoryEnum

  #
  regulations: [RegulatoryRelation!]!

  #
  recommendations: FindingRecommendations!
    @deprecated(reason: "Use recommendation node instead")
}

#
type IssueCodeSample {
  #
  platform: PlatformEnum

  # Indicates what kind of syntax to expect for the associated code block.
  syntax: IssueCodeSyntaxType!

  # Markdown field describing code sample.
  caption: String!

  # Code sample text block.
  block: String!
}

# Enum describing different language/syntax types for syntax highlighting purposes.
enum IssueCodeSyntaxType {
  #
  xml

  #
  kotlin

  #
  swift

  #
  java

  #
  plist

  #
  objc

  #
  gradle

  #
  bash

  #
  cpp
}

#
type IssueGuidanceLink {
  #
  platform: PlatformEnum

  #
  caption: String!

  #
  url: URL
}

# The URL scalar type represents URL addresses.
scalar URL

#
enum VulnerabilityCategoryEnum {
  #
  code

  #
  network

  #
  ipc

  #
  permissions

  #
  storage

  #
  api

  #
  fs

  #
  networking
}

# Categorization of possible vulnerability severities types
enum VulnerabilitySeverityCategoryEnum {
  #
  low

  #
  medium

  #
  high

  #
  critical

  #
  info
}

# Attack complexity categorization
enum AttackComplexityCategoryEnum {
  #
  low

  #
  high
}

# Privileges necessary to execute attack
enum AttackPrivilegesCategoryEnum {
  #
  none

  #
  low

  #
  high
}

# Attack vector categorization
enum AttackVectorCategoryEnum {
  #
  network

  #
  adjecent

  #
  local

  #
  physical
}

# Regulatory relation definition
type RegulatoryRelation {
  #
  type: RegulatoryTypeEnum!

  #
  label: String!

  #
  links: [RegulatoryLink!]!
}

# Regulatory link description
type RegulatoryLink {
  #
  title: String!

  #
  url: URL
}

# Recommendation content, tailored for a specific audience, suggesting potential remediations upon finding a given issue.
type FindingRecommendations {
  # Markdown content with remediation recommendations for application developers.
  developer: String
}

#
type RegulatoryComplianceEvaluationInstructions {
  # Identifier of regulation within specific regulatory compliance regime.
  id: ID!

  # Title of regulation as defined by regulatory compliance regime.
  title: String

  # Defintion of the regulation.
  regulation: DescriptionBlock!

  # Additional Notes
  notes: DescriptionBlock

  # Evaluation Activity
  activity: RegulatoryComplianceEvaluationActivity

  # Guidance instructions written by NowSecure
  nowSecureGuidance(
    # Optionally get the NowSecure guidance for just one platform
    platform: PlatformEnum
  ): DescriptionBlock
}

#
type DescriptionBlock implements DescriptionNode {
  #
  description: String!
}

#
interface DescriptionNode {
  #
  description: String!
}

#
type RegulatoryComplianceEvaluationActivity {
  # TSS
  tss: DescriptionBlock

  # Guidance
  guidance: DescriptionBlock

  # Tests
  tests: DescriptionBlock!
}

#
type FindingContextMetadata {
  # How the UI should render the finding context data.
  view: FindingContextViewEnum!

  # Title of the context data.
  title: String

  # Field definitions for the context data.
  fields: [FindingContextField!]

  # Finding context definitions can recursively contain child definitions
  children: [FindingContextMetadata!]
}

# Represents layout mode to use when rendering underlying context data in a given report.
enum FindingContextViewEnum {
  #
  table

  #
  certificate

  #
  inspector

  #
  text
}

#
type FindingContextField {
  # Key which represents a specific fact within a given findings context.
  key: String!

  # Title of the field.
  title: String!

  # More verbose description of the field.
  description: String

  # How the the UI should format context data (TODO: enum?).
  format: String

  # Template to generate the data from JSON.
  template: String
}

#
enum EvaluationRequirementStatusEnum {
  # Not enough information to automatically infer affected status, and no user action taken.
  needs_review

  # User explicitly set to pass.
  user_pass

  # Tested and inferred to pass, no user action taken.
  auto_pass

  # Tested and inferred to fail, no user action taken.
  auto_fail

  # User explicitly set to fail.
  user_fail
}

#
enum FindingAdjustmentEnum {
  #
  affected

  #
  cvss

  #
  hidden

  #
  note

  #
  shortRemediation
}

# Represents a user's "change" to a finding, overriding the automatically assigned or default values to
# finding properties via operations.
type UserChange {
  # The date this change was applied
  date: DateTime!

  # The user that made this change
  user: UserChangeUser!
}

# Represents a user that has made a "user change" to a finding
type UserChangeUser {
  #
  ref: UUID!

  #
  name: String!
}

# An compliance catalog available for compliance reports.
enum ComplianceReportCatalog {
  #
  MASVS
}

# A relation that associates a finding with a specific control in a group for a particular compliance report catalog.
type ComplianceReportRelation {
  # The compliance report catalog for the relation.
  catalog: ComplianceReportCatalog!

  # Identifies the group within the compliance report catalog for the relation.
  groupId: ID!

  # Identifies the control within the complaince report catalog for the relation.
  controlId: ID!
}

#
type FindingContext {
  # Identity of the check the data was generated for.
  checkId: FindingCheckID!

  # Optional content detailing specific finding context.
  description: String

  # Context-specific set of facts associated with finding.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  items: [JSON!]

  # Optionally, a finding context record can recursively contain children contexts.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  children: [FindingContextSection!]
}

#
type FindingContextSection {
  #
  checkId: FindingCheckID @deprecated(reason: "no need for this -- do not use")

  # Identifier representing the specific context entry for a given finding definition.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  id: ID

  # Optional content detailing specific finding context.
  description: String

  # Context-specific set of facts associated with finding.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  items: [JSON!]

  # Optionally, a finding context record can recursively contain children contexts.
  children: [FindingContextSection!]
}

# Provides metadata on an uploaded file associated with a particular assessment and finding
type FindingAttachment {
  # Assessment the attachment is associated with
  assessmentRef: UUID!

  # Finding the attachment is associated with
  checkId: FindingCheckID!

  # Unique identifier for the attachment
  ref: UUID!

  # Size (in bytes) of the attachment
  byteSize: Int

  # Filename of the attachment
  filename: String

  # Content-type of the attachment
  contentType: String

  # URL to download the attachment
  url: String
}

# A NIAP pre-evaluation assertion captures the stated assumptions of the evaluator about the application being evaluated at the start of the evaluation.
type NiapRequirementAssertion {
  # Represents the identify of the specific NIAP requirement.
  id: FindingCheckID!

  # Represents the selected state of a given NIAP requirement.
  #
  # Note: the backend treats this as nothing more than an opaque JSON dump for now, but we may eventaully want to teach the backend to understand this structure.
  # In the meantime this is flagged as @experimental as it's not something customers should count on to stay stable or to be meaningful in any useful way.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  data: JSON!
}

#
type Country {
  # Country identifier, as lowercase alpha-2 code enum
  id: CountryID!

  # Country name, e.g. ![Mayotte](http://www.kreativekorp.com/lib/flags/yt.png) Mayotte
  name: String!

  # [ISO 3166-1 alpha-2 code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)
  alpha2: String!

  # [ISO 3166-1 alpha-3 code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3)
  alpha3: String!

  # [ISO 3166-1 numeric code](https://en.wikipedia.org/wiki/ISO_3166-1_numeric)
  numeric: String!

  # Platforms that this country has an app store storefront for.
  platforms: [PlatformEnum!]

  # URL to country flag.
  flagURL: URL!
}

#
type Location {
  # The locations reference ID
  ref: String!

  # The type of location
  type: LocationType!

  # The locations data for a given assessment
  data: LocationData!
}

#
enum LocationType {
  #
  BACKTRACE

  #
  FILE
}

#
union LocationData = FileLocation | BacktraceLocation

#
type FileLocation {
  # The location type
  type: String!

  # The file path
  file: String!

  # The starting index in the file
  start: Int!

  # The ending index in the file
  end: Int!
}

#
type BacktraceLocation {
  # The type of the backtrace location entries
  type: BacktraceLocationEntryType!

  # The entries for the backtrace
  entries: [BacktraceLocationEntry!]!
}

#
enum BacktraceLocationEntryType {
  #
  NATIVE

  #
  JAVA

  #
  CSHARP
}

#
union BacktraceLocationEntry =
    BacktraceContextNative
  | BacktraceContextJava
  | BacktraceContextCSharp

#
type BacktraceContextNative {
  # Offset in bytes of the entry's executable code from the beginning of the file described by the 'origin' field of the entry
  byteOffset: Int!

  # High level classification of the origin: 'system' entries belong to any system-provided component, while 'app' or 'framework' ones live in the app bundle
  where: BacktraceContextNativeClassificationType!

  # Debug symbol or language-specific named construct containing the entry's executable code, if available
  address: String!

  # Debug symbol or language-specific named construct containing the entry's executable code, if available
  symbol: String

  # Source location data
  source: SourceLocation
}

#
enum BacktraceContextNativeClassificationType {
  #
  APP

  #
  FRAMEWORK

  #
  SYSTEM
}

#
type SourceLocation {
  # The name of the source location
  name: String!

  # The line number of the source location
  line: Int!
}

#
type BacktraceContextJava {
  # The field / function signature
  signature: String!

  # The name of the encapsulating class
  className: String!

  # The name of the method
  methodName: String!

  # The flags for the field / function
  flags: [BacktraceContextJavaFlag!]!

  # The field name
  fieldName: String

  # Source location data
  source: SourceLocation
}

#
enum BacktraceContextJavaFlag {
  #
  SYNTHETIC
}

#
type BacktraceContextCSharp {
  # The .NET module namespace
  module: String!

  # The name of the method
  methodName: String

  # The name of the field
  fieldName: String

  # Source location data
  source: SourceLocation
}

#
type AutoAssessmentAnalysis implements AssessmentAnalysis {
  # Analysis request task.
  task: AnalysisTask!

  # Overall status of the assessment analysis.
  status: String!

  # The error code associated with exception which occurred during analysis.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  errorCode: String

  # Error which occurred during analysis.
  error: AnalysisError @deprecated(reason: "use errorCode")

  # True if assessment was cancelled while still in progress.
  isCancelled: Boolean!

  # True if either static or dynamic analysis is currently running.
  isRunning: Boolean!

  # True if associated analysis tasks both for static and dynamic have completed successfully.
  isComplete: Boolean!

  # All analysis events that were recorded for this assessment.
  events: [AnalysisEvent!]!

  # Events that were recorded during the analysis.
  eventLog(
    limit: Int = 100
    after: EventLogItemSortKey
    eventTypes: [EventLogItemEventTypeEnum!]
  ): [EventLogItem]

  # Screenshots taken during analysis
  screenshots(sortBy: AnalysisScreenshotSortField): [AnalysisScreenshot!]

  # All artifacts generated during the assessment analysis such as HAR, BEAT, log files, etc
  artifacts(
    sortBy: AnalysisArtifactSortField
    artifactType: AnalysisArtifactType
  ): [AnalysisArtifact!]

  #
  artifact: AnalysisTask! @deprecated(reason: "use task")
}

# Represents set of underlying analysis tasks and associated status and results.
interface AssessmentAnalysis {
  # True if both static and dynamic have completed successfully.
  isComplete: Boolean!

  # The error code associated with exception which occurred during analysis.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  errorCode: String
}

# Represents set of underlying analysis request tasks, along with top-level status information for task.
type AnalysisTask {
  # Dynamic analysis job details
  dynamic: AnalysisJob!

  # Static analysis job details
  static: AnalysisJob!
}

#
type AnalysisJob {
  # Status of the individual analysis job
  status: String!

  # Last time the analysis job updated
  modifiedAt: DateTime

  # Events that were recorded during the analysis
  events: [AnalysisEvent!]!

  # Boolean indicating whether or not an analysis is still in progress
  isRunning: Boolean!

  # True if analysis has completed successfully
  isComplete: Boolean!

  # Raw error message associated with analysis job
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  emsg: String
}

#
type AnalysisEvent {
  # Unique entity ref representing event
  ref: UUID!

  # Kind of event
  kind: AnalysisJobTypeEnum!

  # Assessment the event was for
  assessmentRef: UUID!

  # For UI backwards compatability
  analysisType: AnalysisJobTypeEnum! @deprecated(reason: "Use kind.")

  # Message describing the event
  message: String

  # Key for artifact
  artifactKey: String

  # URL for artifact
  #
  # - TODO
  #   - deprecate in favor of artifactURL for consisting naming
  artifactUrl: String

  # When the event was recorded
  recordedAt: DateTime!
}

#
enum AnalysisJobTypeEnum {
  #
  dynamic

  #
  static

  #
  yaapStatic

  #
  yaapFilter

  #
  workflow

  #
  appDownload
}

#
type AnalysisError {
  # An error code for the assessment analysis
  code: String!

  # Human readable message for the error (TODO)
  message: String!
}

# The EventLogItemSortKey scalar type is a key representing an EventLogItem's sort order in an event log.
scalar EventLogItemSortKey

#
enum EventLogItemEventTypeEnum {
  #
  message

  #
  screenshot

  #
  warning

  #
  error
}

#
type EventLogItem {
  # Unique entity ref representing the event log item.
  ref: UUID!

  # Unique entity ref representing a parent event log item.
  parent: UUID

  # recordedAt;recordedOrder - a key that can be used for sorting the events.
  sortKey: EventLogItemSortKey!

  # The type of analysis event.
  eventType: EventLogItemEventTypeEnum

  # The underlying analysis job type which lead to analysis event.
  kind: AnalysisJobTypeEnum!

  # The log message content.
  message: String

  # Key for artifact
  artifactKey: String

  # URL for artifact
  artifactURL: String

  # When the event was recorded
  recordedAt: DateTime

  # The time duration since the first log in seconds
  duration: Float
}

#
enum AnalysisScreenshotSortField {
  #
  filename

  #
  created

  #
  size
}

#
type AnalysisScreenshot {
  # Assessment the screenshot is from
  assessmentRef: UUID!

  # Unique identifier for the screenshot
  ref: UUID!

  # Size (in bytes) of the screenshot file
  byteSize: Int

  # Filename
  filename: String

  # Content-type of the file
  contentType: String

  # URL to the screenshot
  url: String
}

#
enum AnalysisArtifactSortField {
  #
  filename

  #
  created

  #
  size
}

#
enum AnalysisArtifactType {
  #
  HAR

  #
  BEAT
}

#
type AnalysisArtifact {
  # Assessment related to the artifact
  assessmentRef: UUID!

  # Unique identifier for the artifact
  ref: UUID!

  # Artifact type distinguishes between different types of artifacts such as HAR, BEAT, etc.
  artifactType: AnalysisArtifactType

  # Tags related to the artifact
  tags: String

  # The text to display for the download link
  displayName: String

  # Size (in bytes) of the artifact file
  byteSize: Int

  # Filename (original filename)
  filename: String

  # Content-type of the artifact
  contentType: String

  # URL to download the artifact
  url: String
}

#
type AssessmentReport {
  # Timestamp associated with creation date of report.
  createdAt: DateTime!

  # Specific finding in the report.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  finding(checkId: FindingCheckID!): Finding

  # Findings in the report.
  findings(
    # Set true to include hidden findings.
    hidden: Boolean

    # Set true to include indeterminate findings.
    indeterminate: Boolean

    # Set the sort type, defaults to impact descending.
    order: FindingSortOrder
  ): [Finding!]!

  # Retreive the printURL for this report.
  printURL(
    # Override the format, defaults to PDF.
    format: AssessmentReportPrintFormatEnum

    # Override whether or not to show Report Summary
    showReportSummary: Boolean

    # Override whether or not to show Findings Summary
    showFindingsSummary: Boolean

    # Override whether or not to show Evaluation Counts
    showEvaluationCounts: Boolean

    # Override whether or not to show Screenshots
    showScreenshots: Boolean

    # Override whether or not to show Detailed Findings
    showFindingDetails: Boolean

    # Override whether or not to show Hidden Findings
    showHiddenFindings: Boolean

    # Set which enums to render, defaults to all if not specified
    showImpacts: [FindingImpactTypeEnum!]

    # Override whether or not to show Integration Ticket
    showIntegrationTicket: Boolean

    # Override whether or not to show Finding Description
    showFindingVulnerability: Boolean

    # Override whether or not to show Steps to Reproduce
    showFindingDescription: Boolean

    # Override whether or not to show Remediation Resources
    showFindingRecommendation: Boolean

    # Set which enums to render, defaults to all if not specified
    showFindingRegulations: [RegulatoryTypeEnum!]

    # Override whether or not to show Business Impact
    showFindingImpact: Boolean

    # Override whether or not to show Notes
    showFindingNotes: Boolean

    # Override whether or not to show New Findings / Evaluation Activity
    showFindingCompliance: Boolean

    # Override whether or not to show Finding Evidence
    showFindingContext: Boolean
  ): String!

  #
  score: Float @deprecated(reason: "Use score on associated assessment node.")
}

#
input FindingSortOrder {
  #
  field: FindingSortFieldEnum!

  #
  descending: Boolean
}

# Finding sort types
enum FindingSortFieldEnum {
  #
  analysis

  #
  category

  #
  impact

  #
  affected
}

#
enum AssessmentReportPrintFormatEnum {
  #
  pdf

  #
  html
}

#
enum AnalysisConfigLevel {
  #
  BASELINE

  #
  ADVANCED

  #
  GUIDED
}

#
type NetworkConnectionObservation {
  #
  ip: IPAddress

  #
  domain: String

  #
  host: String

  #
  isp: String

  #
  city: String

  #
  region: String

  #
  country: String
}

#
type CryptoMethodObservation {
  #
  method: String!

  #
  count: Int

  #
  datas: [JSON!]

  #
  isWeak: Boolean
}

#
type SensitiveDataObservation {
  #
  scope: String!

  #
  full_url: String

  #
  searched_data: JSON

  #
  sensitive_data_value: JSON

  #
  encoded_format: String
}

#
type JailbreakDetectionObservation {
  #
  type: String

  #
  path: JSON

  #
  name: String

  #
  args: JSON

  #
  result: JSON

  #
  timestamp: JSON
}

#
union RawAnalysis = RawIosAnalysis | RawAndroidAnalysis

#
type RawIosAnalysis {
  #
  platform: PlatformEnum!

  #
  dynamic: RawIosDynamic

  #
  static: RawIosStatic

  #
  yaap: RawIosYaap
}

#
type RawIosDynamic {
  #
  run_summary: RawIosDynamicRunSummary!

  #
  ispy_report_summary: RawIosDynamicIspyReportSummary!

  #
  network_issue_summary: [RawIosDynamicNetworkIssue]!
}

#
type RawIosDynamicRunSummary {
  #
  multi_pass: Boolean!

  #
  device_udid: ID!

  #
  analysis_time: Float!

  #
  analysis_revision: String!

  #
  start_analysis_timestamp: Float!
}

#
type RawIosDynamicIspyReportSummary {
  # The ispy report summary version
  v: String!

  #
  asl: IspyASL

  #
  ips: [IPAddress]

  #
  path: String

  #
  uuid: IspyUUID

  #
  geoip: [ISpyGeoIP]

  #
  oslog: [IspyOSLog]

  #
  config: IspyConfig

  #
  sqlite: IspySQLite

  #
  network: IspyNetwork

  #
  coverage: IspyCoverage

  #
  keychain: IspyKeychain

  #
  nsbundles: IspyNSBundles

  #
  appmodules: [IspyAppModule]

  #
  mainBundle: IspyNSBundle

  #
  parseErrors: [JSON]

  #
  protections: JSON

  #
  afnetworking: IspyAFNetworking

  #
  parseWarnings: [JSON]

  #
  cfurlconnections: JSON

  #
  sensitive_data_flows: [IspySensitiveDataFlow]

  #
  sensitive_data_leaks: [IspySensitiveData]

  #
  tcp_connection_create: [IspyTCPConnection]
}

#
type IspyASL {
  #
  messages: [ISpyASLMessage]!
}

#
type ISpyASLMessage {
  #
  Message: String!
}

#
type IspyUUID {
  #
  idfv: UUID!

  #
  count: Int!
}

#
type ISpyGeoIP {
  #
  ip: IPAddress!

  #
  fields: ISpyGeoIPFields!
}

#
type ISpyGeoIPFields {
  #
  ip: IPAddress!

  #
  isp: String!

  #
  city: String!

  #
  ip_no: String!

  #
  domain: String!

  #
  region: String!

  #
  status: String!

  #
  latitude: Float!

  #
  elevation: Float!

  #
  longitude: Float!

  #
  country_long: String!

  #
  country_short: String!
}

#
type IspyOSLog {
  #
  data: [JSON]!

  #
  format: String!
}

#
type IspyConfig {
  #
  config: String!

  #
  device: String!

  #
  jailed: Boolean!

  #
  outdir: String!

  #
  probes: JSON!

  #
  report: IspyConfigReport!

  #
  configs: [String]!

  #
  artifacts: IspyConfigArtifacts!

  #
  statusMsg: IspyConfigStatusMsg!

  #
  dumpConfig: Boolean!

  #
  interaction: IspyConfigInteraction!

  #
  runAllProbes: Boolean!
}

#
type IspyConfigReport {
  #
  datasize: Int!
}

#
type IspyConfigArtifacts {
  #
  oslogFile: String!

  #
  xclogFile: String!

  #
  outputFile: String!

  #
  interactionFile: String!
}

#
type IspyConfigStatusMsg {
  #
  level: String!
}

#
type IspyConfigInteraction {
  #
  record: Boolean!
}

#
type IspySQLite {
  #
  misc: [IspySQLiteMiscItem]!

  #
  files: [String]!

  #
  texts: [String]!

  #
  queries: [String]!

  #
  results: [String]!

  #
  snprintf: [String]!
}

#
type IspySQLiteMiscItem {
  #
  args: JSON!

  #
  name: String!

  #
  scope: String!

  #
  result: String!

  #
  timestamp: Long!
}

# The `Long` scalar type represents 52-bit integers
scalar Long

#
type IspyNetwork {
  #
  sessions: JSON!

  #
  urls: [String]

  #
  callback: [IspyNetworkCallback]
}

#
type IspyNetworkCallback {
  #
  args: JSON!

  #
  data: String!

  #
  name: String!

  #
  scope: String!

  #
  base64: Boolean!

  #
  timestamp: Long!
}

#
type IspyCoverage {
  #
  logs: Int!

  #
  files: Int!

  #
  screens: Int!

  #
  connections: Int!
}

#
type IspyKeychain {
  #
  events: [IspyKeychainEvent]!
}

#
type IspyKeychainEvent {
  #
  name: String!

  #
  params: JSON!
}

#
type IspyNSBundles {
  #
  name: String!

  #
  bundles: [IspyNSBundle]!
}

#
type IspyNSBundle {
  #
  identifier: String!

  #
  info: IspyNSBundleInfo!
}

#
type IspyNSBundleInfo {
  #
  CFBundleName: String!

  #
  CFBundleVersion: String!

  #
  MinimumOSVersion: String!

  #
  DTPlatformVersion: String!

  #
  CFBundleExecutable: String!

  #
  CFBundleShortVersionString: String!
}

#
type IspyAppModule {
  #
  name: String!

  #
  imports: [String]!

  #
  timestamp: Long!
}

#
type IspyAFNetworking {
  #
  tests: [IspyAFNetworkingTest]!

  #
  version: IspyAFNetworkingVersion
}

#
type IspyAFNetworkingTest {
  #
  name: String!

  #
  used: Boolean!

  #
  tests: JSON!

  #
  module: String!
}

#
type IspyAFNetworkingVersion {
  #
  name: String!

  #
  used: Boolean!

  #
  tests: JSON!

  #
  module: String!

  #
  scope: String!

  #
  version: Int!

  #
  timestamp: Long!
}

#
type IspySensitiveDataFlow {
  #
  scope: String!

  #
  full_url: String!

  #
  searched_data: String!

  #
  encoded_format: String!

  #
  data_value_type: String!

  #
  sensitive_data_value: String!
}

#
type IspySensitiveData {
  #
  scope: String!

  #
  full_url: String!

  #
  searched_data: String!

  #
  encoded_format: String!

  #
  data_value_type: String!

  #
  sensitive_data_value: String!
}

#
type IspyTCPConnection {
  #
  ip: IPAddress!

  #
  ips: [IPAddress]!

  #
  address: String!

  #
  connection: Int!
}

#
type RawIosDynamicNetworkIssue {
  #
  src: NetworkIssueSrc

  #
  date: DateTime

  #
  dest: NetworkIssueDest

  #
  issue: String

  #
  base64: Boolean

  #
  content: String

  #
  headers: JSON

  #
  full_url: String

  #
  protocol: String

  #
  searched_data: String

  #
  encoded_format: String

  #
  data_value_type: String

  #
  additional_context: [String]

  #
  sensitive_data_value: String
}

#
type NetworkIssueSrc {
  #
  ip: IPAddress!

  #
  port: Int!
}

#
type NetworkIssueDest {
  #
  name: IPAddress!

  #
  port: Int!
}

#
type RawIosStatic {
  #
  meta_data: RawIosStaticMetaData!
}

#
type RawIosStaticMetaData {
  #
  name: String!

  #
  arm64: StaticMetaDataArm64!

  #
  plist: JSON!

  #
  bundleId: String!

  #
  file_type: String!

  #
  shortVersion: String!

  #
  architectures: [String]!

  #
  bundleVersion: String!

  #
  backgroundModes: [String]!

  #
  any_exec_encrypted: Boolean!

  #
  requiredDeviceCapabilities: [String]!
}

#
type StaticMetaDataArm64 {
  #
  bitcode: Boolean!

  #
  signers: String!

  #
  behaviour: [String]!

  #
  encrypted: Boolean!

  #
  entitlements: JSON!

  #
  import_libraries: [String]!
}

#
type RawIosYaap {
  #
  complete: RawIosYaapComplete!

  #
  filtered: RawIosYaapFiltered!
}

#
type RawIosYaapComplete {
  #
  results: [IosYaapCompleteResults]!
}

#
type IosYaapCompleteResults {
  #
  yaap: SemanticVersion!

  #
  tests: [String]!

  #
  ios_hash_vuln: IosHashVulnTest!

  #
  niap_ios_asymmetric: NiapIosAsymmetricTest!

  #
  niap_ios_mem: NiapIosMemTest!

  #
  niap_ios_random_generator: NiapIosRandomGeneratorTest!
}

#
type IosHashVulnTest {
  #
  tests: [String]!

  #
  method_calls: YaapTestMethodCalls
}

#
type YaapTestMethodCalls {
  #
  data: [YaapTestMethodCallsData]!

  #
  found: Boolean

  #
  duration_ms: Int
}

#
type YaapTestMethodCallsData {
  #
  api: String!

  #
  line: Int!

  #
  method: String!

  #
  source_file: String!
}

#
type NiapIosAsymmetricTest {
  #
  tests: [String]!

  #
  method_calls: YaapTestMethodCalls
}

#
type NiapIosMemTest {
  #
  tests: [String]!

  #
  method_args: YaapTestMethodArgs
}

#
type YaapTestMethodArgs {
  #
  data: [YaapTestMethodArgsData]!

  #
  found: Boolean

  #
  duration_ms: Int
}

#
type YaapTestMethodArgsData {
  #
  line: Int!

  #
  method: String!

  #
  location: String!

  #
  arguments: [YaapTestMethodArgsDataArgs]!

  #
  source_file: String!

  #
  instance_type: String!
}

#
type YaapTestMethodArgsDataArgs {
  #
  type: String!

  #
  value: String!
}

#
type NiapIosRandomGeneratorTest {
  #
  tests: [String]!

  #
  strings: YaapTestStrings

  #
  method_calls: YaapTestMethodCalls
}

#
type YaapTestStrings {
  #
  data: YaapTestStringsData!

  #
  found: Boolean

  #
  duration_ms: Float
}

#
type YaapTestStringsData {
  #
  file: [String]!

  #
  native: [YaapTestStringsDataNativeItem]!
}

#
type YaapTestStringsDataNativeItem {
  #
  name: String!

  #
  values: [String]!
}

#
type RawIosYaapFiltered {
  #
  yaap: SemanticVersion!

  #
  checked_rules: [YaapCheckedRulesItem]!

  #
  info: [IosYaapFilteredInfo]!

  #
  Addresses: IosYaapFilteredRuleAddresses

  #
  ApiKeys: YaapFilteredRuleApiKeys

  #
  Bluetooth: YaapFilteredRuleBluetooth

  #
  Calendar: YaapFilteredRuleCalendar

  #
  Camera: YaapFilteredRuleCamera

  #
  Certificate: YaapFilteredRuleCertificate

  #
  EmbeddedCerts: IosYaapFilteredRuleEmbeddedCerts

  #
  FileTypes: YaapFilteredRuleFileTypes

  #
  Fingerprint: YaapFilteredRuleFingerprint

  #
  Hash: IosYaapFilteredRuleHash

  #
  HashVuln: YaapFilteredRuleHashVuln

  #
  Internet: YaapFilteredRuleInternet

  #
  Keychain: IosYaapFilteredRuleKeychain

  #
  LibraryInfo: YaapFilteredRuleLibraryInfo

  #
  Location: YaapFilteredRuleLocation

  #
  LocationBackground: YaapFilteredRuleLocationBackground

  #
  LocationPhoto: YaapFilteredRuleLocationPhoto

  #
  MacVuln: YaapFilteredRuleMacVuln

  #
  Microphone: YaapFilteredRuleMicrophone

  #
  Nfc: YaapFilteredRuleNfc

  #
  PhoneCalls: YaapFilteredRulePhoneCalls

  #
  PrivateFrameworks: YaapFilteredRulePrivateFrameworks

  #
  ReadContacts: YaapFilteredRuleReadContacts

  #
  SSP: YaapFilteredRuleSSP

  #
  Usb: YaapFilteredRuleUsb
}

#
union YaapCheckedRulesItem =
    YaapCheckedRulesGeneralItem
  | YaapCheckedRulesVulnItem

#
type YaapCheckedRulesGeneralItem {
  #
  general: [String]!
}

#
type YaapCheckedRulesVulnItem {
  #
  vuln: [String]!
}

#
type IosYaapFilteredInfo {
  #
  file_info: IosYaapFilteredInfoFileInfo!
}

#
type IosYaapFilteredInfoFileInfo {
  #
  md5: String!

  #
  sha1: String!

  #
  sha256: String!

  #
  app_name: String!

  #
  bundle_id: String!

  #
  macho_info: [IosYaapFilteredMachoInfo]!

  #
  app_name_exec: String!

  #
  analyzed_files: [String]!

  #
  bundle_version: String!

  #
  short_bundle_id: String!
}

#
type IosYaapFilteredMachoInfo {
  #
  arc: Boolean!

  #
  pac: Boolean!

  #
  pic: Boolean!

  #
  ssp: Boolean!

  #
  name: String!

  #
  stripped: Boolean!

  #
  big_endian: Boolean!

  #
  constructor: Boolean!

  #
  additional_info: IosYaapFilteredMachoInfoAdditionalInfo!

  #
  sha1: String

  #
  file_type: String

  #
  binary_type: String

  #
  machine_type: String
}

#
type IosYaapFilteredMachoInfoAdditionalInfo {
  #
  libs: [String]!

  #
  sha1: String

  #
  file_type: String

  #
  binary_type: Int

  #
  machine_type: String
}

#
type IosYaapFilteredRuleAddresses {
  #
  cvss: String!

  #
  niap: [String]!

  #
  flags: [String]!

  #
  links: [YaapFilteredLinkItem]!

  #
  header: String!

  #
  description: String!

  #
  matched_tests: [String]!

  #
  recommendation: String!

  #
  symbols: IosYaapTestSymbols
}

#
type YaapFilteredLinkItem {
  #
  os: String!

  #
  url: String!

  #
  type: String!
}

#
type IosYaapTestSymbols {
  #
  data: [String]!
}

#
type YaapFilteredRuleApiKeys {
  #
  cvss: String!

  #
  niap: [String]!

  #
  flags: [String]!

  #
  links: [YaapFilteredLinkItem]!

  #
  header: String!

  #
  description: String!

  #
  matched_tests: [String]!

  #
  recommendation: String!

  #
  combined: YaapTestCombined

  #
  field_values: YaapTestFieldValues

  #
  manifest: AndroidYaapTestManifest

  #
  method_args: YaapTestMethodArgs

  #
  yara: YaapTestYara
}

#
type YaapTestCombined {
  #
  data: [YaapTestCombinedData]!

  #
  found: Boolean

  #
  duration_ms: Int
}

#
type YaapTestCombinedData {
  #
  resource_id: String!

  #
  resource_value: String!
}

#
type YaapTestFieldValues {
  #
  data: JSON!

  #
  found: Boolean

  #
  duration_ms: Float
}

#
type AndroidYaapTestManifest {
  #
  uses_permissions: AndroidYaapTestManifestUsesPermissions!

  #
  errors: Boolean

  #
  duration_ms: Float
}

#
type AndroidYaapTestManifestUsesPermissions {
  #
  data: [String]!

  #
  found: Boolean
}

#
type YaapTestYara {
  #
  matched_rules: [YaapTestYaraMatchedRule]!

  #
  found: Boolean

  #
  duration_ms: Float
}

#
type YaapTestYaraMatchedRule {
  #
  tag: String!

  #
  file: String!

  #
  rule: String!
}

#
type YaapFilteredRuleBluetooth {
  #
  cvss: String!

  #
  niap: [String]!

  #
  flags: [String]!

  #
  links: [YaapFilteredLinkItem]!

  #
  header: String!

  #
  description: String!

  #
  matched_tests: [String]!

  #
  recommendation: String!

  #
  method_calls: YaapTestMethodCalls

  #
  plist: JSON

  #
  symbols: IosYaapTestSymbols
}

#
type YaapFilteredRuleCalendar {
  #
  cvss: String!

  #
  niap: [String]!

  #
  flags: [String]!

  #
  links: [YaapFilteredLinkItem]!

  #
  header: String!

  #
  description: String!

  #
  matched_tests: [String]!

  #
  recommendation: String!

  #
  fields: YaapTestFields

  #
  plist: JSON

  #
  manifest: AndroidYaapTestManifest

  #
  reflection: YaapTestReflection

  #
  symbols: IosYaapTestSymbols
}

#
type YaapTestFields {
  #
  data: [YaapTestFieldsData]!

  #
  found: Boolean

  #
  duration_ms: Float
}

#
type YaapTestFieldsData {
  #
  name: String!

  #
  class: String!
}

#
type YaapTestReflection {
  #
  data: JSON!

  #
  found: Boolean

  #
  duration_ms: Float
}

#
type YaapFilteredRuleCamera {
  #
  cvss: String!

  #
  niap: [String]!

  #
  flags: [String]!

  #
  links: [YaapFilteredLinkItem]!

  #
  header: String!

  #
  description: String!

  #
  matched_tests: [String]!

  #
  recommendation: String!

  #
  fields: YaapTestFields

  #
  plist: JSON

  #
  manifest: AndroidYaapTestManifest

  #
  reflection: YaapTestReflection

  #
  strings: YaapTestStrings

  #
  symbols: IosYaapTestSymbols

  #
  method_calls: YaapTestMethodCalls
}

#
type YaapFilteredRuleCertificate {
  #
  cvss: String!

  #
  niap: [String]!

  #
  flags: [String]!

  #
  links: [YaapFilteredLinkItem]!

  #
  header: String!

  #
  description: String!

  #
  matched_tests: [String]!

  #
  recommendation: String!

  #
  certificate: YaapTestCertificate
}

#
type YaapTestCertificate {
  #
  data: [JSON]!

  #
  found: Boolean

  #
  duration_ms: Float
}

#
type IosYaapFilteredRuleEmbeddedCerts {
  #
  cvss: String!

  #
  niap: [String]!

  #
  flags: [String]!

  #
  links: [YaapFilteredLinkItem]!

  #
  header: String!

  #
  description: String!

  #
  matched_tests: [String]!

  #
  recommendation: String!

  #
  embedded_certs: [YaapFilteredEmbeddedCert]
}

#
type YaapFilteredEmbeddedCert {
  #
  sha1: String!

  #
  issuer: String!

  #
  subject: String!
}

#
type YaapFilteredRuleFileTypes {
  #
  cvss: String!

  #
  niap: [String]!

  #
  flags: [String]!

  #
  links: [YaapFilteredLinkItem]!

  #
  header: String!

  #
  description: String!

  #
  matched_tests: [String]!

  #
  recommendation: String!

  #
  info: YaapTestInfo
}

#
type YaapTestInfo {
  #
  file_names: YaapTestInfoFileNames!

  #
  found: Boolean

  #
  duration_ms: Float

  #
  total_file_names: Int
}

#
type YaapTestInfoFileNames {
  #
  data: [YaapTestInfoFileNamesData]
}

#
type YaapTestInfoFileNamesData {
  #
  hex: String!

  #
  name: String!

  #
  type: String!
}

#
type YaapFilteredRuleFingerprint {
  #
  cvss: String!

  #
  niap: [String]!

  #
  flags: [String]!

  #
  links: [YaapFilteredLinkItem]!

  #
  header: String!

  #
  description: String!

  #
  matched_tests: [String]!

  #
  recommendation: String!

  #
  method_args: YaapTestMethodArgs

  #
  method_calls: YaapTestMethodCalls
}

#
type IosYaapFilteredRuleHash {
  #
  cvss: String!

  #
  niap: [String]!

  #
  flags: [String]!

  #
  links: [YaapFilteredLinkItem]!

  #
  header: String!

  #
  description: String!

  #
  matched_tests: [String]!

  #
  recommendation: String!

  #
  method_calls: YaapTestMethodCalls
}

#
type YaapFilteredRuleHashVuln {
  #
  cvss: String!

  #
  niap: [String]!

  #
  flags: [String]!

  #
  links: [YaapFilteredLinkItem]!

  #
  header: String!

  #
  description: String!

  #
  matched_tests: [String]!

  #
  recommendation: String!

  #
  method_args: YaapTestMethodArgs
}

#
type YaapFilteredRuleInternet {
  #
  cvss: String!

  #
  niap: [String]!

  #
  flags: [String]!

  #
  links: [YaapFilteredLinkItem]!

  #
  header: String!

  #
  description: String!

  #
  matched_tests: [String]!

  #
  recommendation: String!

  #
  manifest: AndroidYaapTestManifest
}

#
type IosYaapFilteredRuleKeychain {
  #
  cvss: String!

  #
  niap: [String]!

  #
  flags: [String]!

  #
  links: [YaapFilteredLinkItem]!

  #
  header: String!

  #
  description: String!

  #
  matched_tests: [String]!

  #
  recommendation: String!

  #
  symbols: IosYaapTestSymbols

  #
  method_calls: YaapTestMethodCalls
}

#
type YaapFilteredRuleLibraryInfo {
  #
  cvss: String!

  #
  niap: [String]!

  #
  flags: [String]!

  #
  links: [YaapFilteredLinkItem]!

  #
  header: String!

  #
  description: String!

  #
  matched_tests: [String]!

  #
  recommendation: String!

  #
  library_info: [String]
}

#
type YaapFilteredRuleLocation {
  #
  cvss: String!

  #
  niap: [String]!

  #
  flags: [String]!

  #
  links: [YaapFilteredLinkItem]!

  #
  header: String!

  #
  description: String!

  #
  matched_tests: [String]!

  #
  recommendation: String!

  #
  fields: YaapTestFields

  #
  manifest: AndroidYaapTestManifest

  #
  method_args: YaapTestMethodArgs

  #
  method_calls: YaapTestMethodCalls

  #
  plist: JSON

  #
  symbols: IosYaapTestSymbols
}

#
type YaapFilteredRuleLocationBackground {
  #
  cvss: String!

  #
  niap: [String]!

  #
  flags: [String]!

  #
  links: [YaapFilteredLinkItem]!

  #
  header: String!

  #
  description: String!

  #
  matched_tests: [String]!

  #
  recommendation: String!

  #
  manifest: AndroidYaapTestManifest
}

#
type YaapFilteredRuleLocationPhoto {
  #
  cvss: String!

  #
  niap: [String]!

  #
  flags: [String]!

  #
  links: [YaapFilteredLinkItem]!

  #
  header: String!

  #
  description: String!

  #
  matched_tests: [String]!

  #
  recommendation: String!

  #
  manifest: AndroidYaapTestManifest

  #
  method_calls: YaapTestMethodCalls
}

#
type YaapFilteredRuleMacVuln {
  #
  cvss: String!

  #
  niap: [String]!

  #
  flags: [String]!

  #
  links: [YaapFilteredLinkItem]!

  #
  header: String!

  #
  description: String!

  #
  matched_tests: [String]!

  #
  recommendation: String!

  #
  method_args: YaapTestMethodArgs
}

#
type YaapFilteredRuleMicrophone {
  #
  cvss: String!

  #
  niap: [String]!

  #
  flags: [String]!

  #
  links: [YaapFilteredLinkItem]!

  #
  header: String!

  #
  description: String!

  #
  matched_tests: [String]!

  #
  recommendation: String!

  #
  manifest: AndroidYaapTestManifest

  #
  method_calls: YaapTestMethodCalls

  #
  plist: JSON

  #
  reflection: YaapTestReflection

  #
  strings: YaapTestStrings

  #
  symbols: IosYaapTestSymbols
}

#
type YaapFilteredRuleNfc {
  #
  cvss: String!

  #
  niap: [String]!

  #
  flags: [String]!

  #
  links: [YaapFilteredLinkItem]!

  #
  header: String!

  #
  description: String!

  #
  matched_tests: [String]!

  #
  recommendation: String!

  #
  fields: YaapTestFields

  #
  manifest: AndroidYaapTestManifest

  #
  method_calls: YaapTestMethodCalls

  #
  reflection: YaapTestReflection

  #
  strings: YaapTestStrings

  #
  symbols: IosYaapTestSymbols

  #
  plist: JSON
}

#
type YaapFilteredRulePhoneCalls {
  #
  cvss: String!

  #
  niap: [String]!

  #
  flags: [String]!

  #
  links: [YaapFilteredLinkItem]!

  #
  header: String!

  #
  description: String!

  #
  matched_tests: [String]!

  #
  recommendation: String!

  #
  manifest: AndroidYaapTestManifest

  #
  method_calls: YaapTestMethodCalls

  #
  strings: YaapTestStrings
}

#
type YaapFilteredRulePrivateFrameworks {
  #
  cvss: String!

  #
  niap: [String]!

  #
  flags: [String]!

  #
  links: [YaapFilteredLinkItem]!

  #
  header: String!

  #
  description: String!

  #
  matched_tests: [String]!

  #
  recommendation: String!

  #
  library_info: [String]

  #
  private_frameworks: YaapTestPrivateFrameworks

  #
  method_args: YaapTestMethodArgs
}

#
type YaapTestPrivateFrameworks {
  #
  data: JSON!

  #
  found: Boolean

  #
  duration_ms: Float
}

#
type YaapFilteredRuleReadContacts {
  #
  cvss: String!

  #
  niap: [String]!

  #
  flags: [String]!

  #
  links: [YaapFilteredLinkItem]!

  #
  header: String!

  #
  description: String!

  #
  matched_tests: [String]!

  #
  recommendation: String!

  #
  fields: YaapTestFields

  #
  manifest: AndroidYaapTestManifest

  #
  method_args: YaapTestMethodArgs

  #
  method_calls: YaapTestMethodCalls

  #
  reflection: YaapTestReflection

  #
  symbols: IosYaapTestSymbols

  #
  plist: JSON
}

#
type YaapFilteredRuleSSP {
  #
  cvss: String!

  #
  niap: [String]!

  #
  flags: [String]!

  #
  links: [YaapFilteredLinkItem]!

  #
  header: String!

  #
  description: String!

  #
  matched_tests: [String]!

  #
  recommendation: String!

  #
  native_files: YaapTestNativeFiles

  #
  ssp: YaapTestSSP
}

#
type YaapTestNativeFiles {
  #
  data: YaapTestNativeFilesData!

  #
  found: Boolean

  #
  duration_ms: Float
}

#
type YaapTestNativeFilesData {
  #
  libs: [String]!

  #
  name: String!

  #
  sha1: String!

  #
  fuzzy: String!

  #
  file_type: String!

  #
  binary_type: String!

  #
  machine_type: String!

  #
  ssp: Boolean!

  #
  correct_soname: Boolean

  #
  non_public_libs: [String]

  #
  text_relocations: Boolean

  #
  has_absolute_path: Boolean

  #
  unsupported_libcpp: Boolean

  #
  correct_section_header: Boolean

  #
  writable_executable_segments: Boolean
}

#
type YaapTestSSP {
  #
  name: [String]!
}

#
type YaapFilteredRuleUsb {
  #
  cvss: String!

  #
  niap: [String]!

  #
  flags: [String]!

  #
  links: [YaapFilteredLinkItem]!

  #
  header: String!

  #
  description: String!

  #
  matched_tests: [String]!

  #
  recommendation: String!

  #
  fields: YaapTestFields

  #
  manifest: AndroidYaapTestManifest

  #
  method_calls: YaapTestMethodCalls

  #
  reflection: YaapTestReflection
}

#
type RawAndroidAnalysis {
  #
  platform: PlatformEnum!

  #
  dynamic: RawAndroidDynamic

  #
  yaap: RawAndroidYaap
}

#
type RawAndroidDynamic {
  #
  file_access: [DynamicFileAccess]!

  #
  fs_issues: [DynamicFSIssue]!

  #
  run_summary: [DynamicRunSummary]!

  #
  leaked_data_in_files: [DynamicLeakedData]!

  #
  network_issues: [DynamicNetworkIssue]!

  #
  sdcard_file_list: [String]!

  #
  snoop_network: DynamicSnoopNetwork!

  #
  stealth_spy: StealthSpyResults!
}

#
type DynamicFileAccess {
  #
  detailed_list: [DynamicFSEvent]!

  #
  simplified_list: [String]!
}

#
type DynamicFSEvent {
  #
  p: Int!

  #
  ts: Long!

  #
  pid: Int!

  #
  ret: Int!

  #
  args: [JSON]!

  #
  call: String!

  #
  timestamp: Long!

  #
  effective_mode: Int

  #
  umask: Int

  #
  resolvedPath: String
}

#
type DynamicFSIssue {
  #
  mode: Int!

  #
  path: String!

  #
  fs_event: DynamicFSEvent!

  #
  violation: String!
}

#
type DynamicRunSummary {
  #
  apk_info: RunSummaryAPKInfo!

  #
  device_info: RunSummaryDeviceInfo!

  #
  analysis_time: Float!

  #
  analysis_revision: String!

  #
  incomplete_report: Boolean!

  #
  current_analysis_version: Int!

  #
  start_analysis_timestamp: Float!
}

#
type RunSummaryAPKInfo {
  #
  md5: String!

  #
  sha1: String!

  #
  minSDK: Int!

  #
  sha256: String!

  #
  services: [String]!

  #
  receivers: [String]!

  #
  targetSDK: Int!

  #
  activities: [String]!

  #
  packageName: String!

  #
  permissions: [String]!

  #
  versionCode: Int!

  #
  mainActivity: String!
}

#
type RunSummaryDeviceInfo {
  #
  dns1: String!

  #
  dns2: String!

  #
  serial: String!

  #
  wifi_ip: String!

  #
  wifi_mac: String!

  #
  android_id: String!

  #
  bluetooth_mac: String!

  #
  build_fingerprint: String!

  #
  provision_version: Int!

  #
  provision_revision: String!

  #
  google_games_version: Int!

  #
  build_version_release: String!

  #
  google_services_version: Int!

  #
  surrounding_wifi_networks: [RunSummaryDeviceInfoWifiNetwork]!
}

#
type RunSummaryDeviceInfoWifiNetwork {
  #
  SSID: String!

  #
  BSSID: String!
}

#
type DynamicLeakedData {
  #
  type: String!

  #
  encoding: String!

  #
  filename: String!
}

#
type DynamicNetworkIssue {
  #
  src: NetworkIssueSrc!

  #
  date: DateTime!

  #
  dest: NetworkIssueDest!

  #
  issue: String!

  #
  base64: Boolean!

  #
  content: String!

  #
  headers: JSON!

  #
  full_url: String!

  #
  protocol: String!

  #
  searched_data: String!

  #
  encoded_format: String!

  #
  data_value_type: String!

  #
  headers_request: JSON!

  #
  headers_response: JSON!

  #
  additional_context: [String]!

  #
  sensitive_data_value: String!
}

#
type DynamicSnoopNetwork {
  #
  hosts: [SnoopNetworkHost]!

  #
  connections: [SnoopNetworkConnection]!
}

#
type SnoopNetworkHost {
  #
  host: String!

  #
  ip: [SnoopNetworkHostIP]!
}

#
type SnoopNetworkHostIP {
  #
  geo: SnoopNetworkHostIPGeo!

  #
  addr: String!

  #
  sa_family: String!
}

#
type SnoopNetworkHostIPGeo {
  #
  isp: String!

  #
  city: String!

  #
  domain: String!

  #
  region: String!

  #
  status: String!

  #
  latitude: Float!

  #
  longitude: Float!

  #
  country_short: String!
}

#
type SnoopNetworkConnection {
  #
  addr: String!

  #
  port: Int!

  #
  sa_family: String!
}

#
type StealthSpyResults {
  #
  all_results: [StealthSpyGenericResult]!

  #
  set_seed_results: [StealthSpySetSeedResult]!

  #
  prediction_resistant_results: [StealthSpyPredictionResistantResult]

  #
  block_size_results: [StealthSpyBlockSizeResult]

  #
  transformation_results: [StealthSpyTransformationResult]

  #
  hash_algorithm_results: [StealthSpyHashAlgorithmResult]

  #
  asymmetric_key_algorithm_results: [StealthSpyAsymmetricKeyAlgorithmResult]
}

#
type StealthSpyGenericResult {
  #
  class: String

  #
  method: String

  #
  service: String

  #
  timestamp: Long

  #
  preferencesName: String

  #
  algorithm: String

  #
  Algorithm: String

  #
  Key: String

  #
  Provider: String

  #
  SQLStatement: String

  #
  broadcastReceiverClassName: String

  #
  generates_asymmetric_key: Boolean

  #
  keysize: Int

  #
  value: Boolean

  #
  generates_message_digest: Boolean

  #
  seed: Int

  #
  intentActions: [String]

  #
  loadedClass: String

  #
  uri: String
}

#
type StealthSpySetSeedResult {
  #
  class: String!

  #
  method: String!

  #
  seed: Int!
}

#
type StealthSpyPredictionResistantResult {
  #
  class: String!

  #
  method: String!

  #
  drbg: Boolean!
}

#
type StealthSpyBlockSizeResult {
  #
  class: String!

  #
  method: String!

  #
  block_size: Int!

  #
  drbg: Boolean!
}

#
type StealthSpyTransformationResult {
  #
  method: String!

  #
  transformation: String!

  #
  provider: String
}

#
type StealthSpyHashAlgorithmResult {
  #
  method: String!

  #
  algorithm: String!

  #
  provider: String
}

#
type StealthSpyAsymmetricKeyAlgorithmResult {
  #
  class: String!

  #
  method: String!

  #
  algorithm: String!
}

#
type RawAndroidYaap {
  #
  complete: RawAndroidYaapComplete!

  #
  filtered: RawAndroidYaapFiltered!
}

#
type RawAndroidYaapComplete {
  #
  results: [AndroidYaapCompleteResults]!
}

#
type AndroidYaapCompleteResults {
  #
  yaap: SemanticVersion!

  #
  tests: [String]!

  #
  total_time_ms: Float!

  #
  start_time: Long!

  #
  modified: DateTime!

  #
  filename: String!

  #
  filetype: String!

  #
  timeout: Boolean!

  #
  analysis: AndroidYaapCompleteAnalysis!

  #
  niap_android_random_generator: NiapAndroidRandomGeneratorTest!

  #
  niap_android_mem: NiapAndroidMemTest!

  #
  niap_android_keystore: NiapAndroidKeystoreTest!

  #
  niap_android_asymmetric: NiapAndroidAsymmetric!
}

#
type AndroidYaapCompleteAnalysis {
  #
  manifest: AndroidYaapCompleteAnalysisManifest!
}

#
type AndroidYaapCompleteAnalysisManifest {
  #
  errors: Boolean!

  #
  app_name: String!

  #
  features: [String]!

  #
  services: [String]!

  #
  providers: [String]!

  #
  receivers: [String]!

  #
  activities: [String]!

  #
  categories: [String]!

  #
  debuggable: Boolean!

  #
  duration_ms: Float!

  #
  allow_backup: Boolean!

  #
  version_code: Int!

  #
  main_activity: String!

  #
  task_affinity: JSON!

  #
  intent_actions: [String]!

  #
  shared_user_id: String!

  #
  max_sdk_version: Int!

  #
  min_sdk_version: Int!

  #
  install_location: String!

  #
  print_components: JSON!

  #
  use_embedded_dex: Boolean!

  #
  native_activities: JSON!

  #
  print_permissions: JSON!

  #
  target_sdk_version: Int!

  #
  exported_components: JSON!

  #
  foreground_service_types: JSON!

  #
  print_declared_permissions: JSON!

  #
  request_legacy_external_storage: Boolean!
}

#
type NiapAndroidRandomGeneratorTest {
  #
  tests: [String]!

  #
  strings: YaapTestStrings

  #
  method_calls: YaapTestMethodCalls
}

#
type NiapAndroidMemTest {
  #
  tests: [String]!

  #
  method_args: YaapTestMethodArgs
}

#
type NiapAndroidKeystoreTest {
  #
  tests: [String]!

  #
  method_args: YaapTestMethodArgs

  #
  method_calls: YaapTestMethodCalls
}

#
type NiapAndroidAsymmetric {
  #
  tests: [String]!

  #
  method_args: YaapTestMethodArgs

  #
  method_calls: YaapTestMethodCalls
}

#
type RawAndroidYaapFiltered {
  #
  yaap: SemanticVersion!

  #
  checked_rules: [YaapCheckedRulesItem]!

  #
  info: [AndroidYaapFilteredInfo]!

  #
  ApiKeys: YaapFilteredRuleApiKeys

  #
  Bluetooth: YaapFilteredRuleBluetooth

  #
  Calendar: YaapFilteredRuleCalendar

  #
  Camera: YaapFilteredRuleCamera

  #
  Certificate: YaapFilteredRuleCertificate

  #
  FileTypes: YaapFilteredRuleFileTypes

  #
  Fingerprint: YaapFilteredRuleFingerprint

  #
  HashVuln: YaapFilteredRuleHashVuln

  #
  Internet: YaapFilteredRuleInternet

  #
  LibraryInfo: YaapFilteredRuleLibraryInfo

  #
  Location: YaapFilteredRuleLocation

  #
  LocationBackground: YaapFilteredRuleLocationBackground

  #
  LocationPhoto: YaapFilteredRuleLocationPhoto

  #
  MacVuln: YaapFilteredRuleMacVuln

  #
  ManifestInfo: AndroidYaapFilteredRuleManifestInfo

  #
  Microphone: YaapFilteredRuleMicrophone

  #
  Nfc: YaapFilteredRuleNfc

  #
  PhoneCalls: YaapFilteredRulePhoneCalls

  #
  PrivateFrameworks: YaapFilteredRulePrivateFrameworks

  #
  ReadContacts: YaapFilteredRuleReadContacts

  #
  SSP: YaapFilteredRuleSSP

  #
  Usb: YaapFilteredRuleUsb

  #
  WriteContacts: AndroidYaapFilteredRuleWriteContacts
}

#
type AndroidYaapFilteredInfo {
  #
  file_info: AndroidYaapFilteredInfoFileInfo!
}

#
type AndroidYaapFilteredInfoFileInfo {
  #
  md5: String!

  #
  sha1: String!

  #
  sha256: String!

  #
  app_name: String!

  #
  dex_info: [AndroidYaapFilteredInfoDexInfo]!

  #
  debuggable: Boolean!

  #
  allow_backup: Boolean!

  #
  package_name: String!

  #
  version_code: Int!

  #
  version_name: String!

  #
  main_activity: String!

  #
  total_methods: Int!

  #
  analyzed_files: [String]!

  #
  companion_apps: [String]!

  #
  max_sdk_version: Int!

  #
  min_sdk_version: Int!

  #
  target_sdk_version: Int!
}

#
type AndroidYaapFilteredInfoDexInfo {
  #
  name: String!

  #
  big_endian: Boolean!

  #
  non_zero_link_size: Boolean!

  #
  non_zero_link_offset: Boolean!

  #
  non_standard_header_size: Boolean!

  #
  injected_data_map_section: Boolean!
}

#
type AndroidYaapFilteredRuleManifestInfo {
  #
  cvss: String!

  #
  niap: [String]!

  #
  flags: [String]!

  #
  links: [YaapFilteredLinkItem]!

  #
  header: String!

  #
  description: String!

  #
  matched_tests: [String]!

  #
  recommendation: String!

  #
  manifest: AndroidYaapTestManifest
}

#
type AndroidYaapFilteredRuleWriteContacts {
  #
  cvss: String!

  #
  niap: [String]!

  #
  flags: [String]!

  #
  links: [YaapFilteredLinkItem]!

  #
  header: String!

  #
  description: String!

  #
  matched_tests: [String]!

  #
  recommendation: String!

  #
  fields: YaapTestFields

  #
  manifest: AndroidYaapTestManifest

  #
  method_args: YaapTestMethodArgs

  #
  reflection: YaapTestReflection
}

#
type AssessmentWorkflow {
  #
  steps: [AssessmentWorkflowStep!]!
}

#
type AssessmentWorkflowStep {
  #
  key: String!

  #
  displayName: String!

  #
  status: AssessmentWorkflowStatus

  #
  emsg: String

  #
  errorCode: String

  # Whether or not this workflow step is optional (if ture, a failure will not fail the whole workflow).
  optional: Boolean

  # Keys referencing the steps immediately following this step.
  downstreamKeys: [ID!]!
}

#
enum AssessmentWorkflowStatus {
  #
  completed

  #
  failed

  #
  cancelled

  #
  pending
}

#
type DistinctRequestUrl {
  # Distinct, normalized URL.
  url: URL!

  #
  scheme: String!

  #
  host: String!

  #
  path: String!

  #
  query: String

  #
  methods: [String]!

  #
  sources: [String!]!

  #
  _raw_urls: [String!]!

  #
  _raw_paths: [String!]!
}

#
type DistinctRequestEndpoint {
  # Distinct, normalized URL.
  endpoint: URL!

  #
  scheme: String!

  #
  host: String!

  #
  path: String!

  #
  queries: [String!]!

  #
  methods: [String]!

  #
  sources: [String!]!

  #
  _raw_urls: [String!]!

  #
  _raw_paths: [String!]!
}

# A report for a particular compliance catalog.
type ComplianceReport {
  # The catalog used for the compliance report.
  catalog: ComplianceReportCatalog!

  # A summary of the controls within this compliance report.
  summary(
    # An optional filter object, which describes a subset of property values to filter the controls in the summary for.
    #
    # For example, filter for extra control properties like: filter: { extra: { L1: true } }.
    filter: JSON
  ): ComplianceReportSummary!

  # A specific control within the compliance report.
  control(id: ID!): ComplianceReportControl

  # A specific group of controls within the compliance report.
  group(id: ID!): ComplianceReportGroup

  # All of the groups of controls within the compliance report.
  groups: [ComplianceReportGroup!]!
}

# A summary of the controls within a compliance report.
type ComplianceReportSummary {
  # The total number of controls in the compliance report.
  totalControls: Int!

  # The total number of controls in the compliance report with the given status.
  totalControlsWithStatus(
    # The status of the controls to get the total for.
    status: ComplianceReportControlStatus!
  ): Int!
}

# Describes the status of a compliance report control as decided by the state of the findings related to the control.
enum ComplianceReportControlStatus {
  # A control is passed if all of our related findings for the control passed testing.
  PASSED

  # A control is failed if one or more of our related findings for the control failed testing.
  FAILED

  # A control is disabled if all of our related findings for the control have been disabled by the user.
  DISABLED

  # A control needs review if none of our related findings for the control failed testing and at least one of them has an impactType of warn.
  NEEDS_REVIEW

  # A control is indeterminate if none of our related findings for the control appeared in the report.
  INDETERMINATE

  # A control is not automatable if automation is not possible. In this case, self-attestation is necessary from the user.
  NOT_AUTOMATABLE

  # A control is not currently automated if automation is possible but not currently implemented.
  NOT_CURRENTLY_AUTOMATED
}

# A control within a compliance report.
type ComplianceReportControl {
  # The compliance report catalog associated with this control.
  catalog: ComplianceReportCatalog!

  # The unique identifying string for this control within the compliance report catalog.
  id: ID!

  # The identifier for the compliance report group this control is a member of.
  groupId: ID!

  # The title of the compliance report control.
  title: String!

  # The description for the compliance report control.
  description: String!

  # The status for the complaince report control as decided by the state of the findings related to it.
  status: ComplianceReportControlStatus!

  # External links related to the compliance report control.
  links: [URL!]

  # Findings related to the compliance report control.
  findings: [Finding]!

  # Any other properties related to the compliance report control.
  extra: JSON
}

# A group of controls within a compliance report.
type ComplianceReportGroup {
  # The compliance catalog associated with this compliance report group.
  catalog: ComplianceReportCatalog!

  # The unique identifying string for this group within the compliance report catalog.
  id: ID!

  # The title of the compliance report group.
  title: String!

  # The description for the compliance report group.
  description: String!

  # A summary of the controls within this compliance report group.
  summary(
    # An optional filter object, which describes a subset of property values to filter the controls in the summary for.
    #
    # For example, filter for extra control properties like: filter: { extra: { L1: true } }.
    filter: JSON
  ): ComplianceReportGroupSummary!

  # A specific control within this compliance report group.
  control(id: ID!): ComplianceReportControl

  # All of the controls within this compliance report group.
  controls: [ComplianceReportControl!]!
}

# A summary of the controls within a compliance report group.
type ComplianceReportGroupSummary {
  # The total number of controls in the compliance report group.
  totalControls: Int!

  # The total number of controls in the compliance report group with the given status.
  totalControlsWithStatus(status: ComplianceReportControlStatus!): Int!
}

#
type IntelApplication implements Application {
  # This is a unique identifier for a given published application.
  ref: ID!

  # Platform targeted by assessment (ios or android).
  platformType: PlatformEnum!

  # Package name (android) or bundle id string (iOS).
  packageKey: String!

  # Application key uniquely identifying application record on platform's default appstore.
  appstoreApplicationKey: ID!

  # Current published version, as surfaced within appstore.
  publishedVersion: String

  # Query over available package versions associated with application.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  packageVersions(
    # Max most recent package version to surface.
    limit: Int
  ): [IntelApplicationPackageVersion!]

  # Current application title, derived from latest published metadata.
  title: String!

  # Current application description
  description: String!

  # URL to application page on app store site.
  appstoreApplicationURL: URL!

  # Icon URL
  iconURL: String

  # Screenshot URLs
  screenshotURLs: [URL!]

  # The date of the latest release. Format: YYYY-MM-DD
  latestReleaseDate: Date

  # Whether or not this application is free
  isFree: Boolean

  # Whether or not this application has been unpublished from app store.
  isUnpublished: Boolean

  # Whether or not this application is in a country NowSecure can scan.
  isAvailableInSupportedCountry: Boolean

  # Whether or not NowSecure can scan this application.
  isScannable: Boolean!

  # Date of recent result we have recorded any analysis of this application we have recorded in our analysis log.
  latestAnalysisRecorded: DateTime

  # For now this will return true only if user cannot see all analysis for a particular application **from within platform org**.
  # Even if user can resolve intel application details via the graph, this only checks whether assessment is available in user's platform org.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  isAnalysisAvailable: Boolean

  # Resolves latest application assessment as of a specific point in time (defaulting to latest).
  assessment(
    # Target a specific assessment for application by uuid ref.
    ref: UUID

    # Resolve latest application assessment as of a given point in time.
    asOf: String

    # The UUID ref of the PolicyVersion to use for rendering the assessment.
    policyVersionRef: UUID
  ): IntelAssessment

  # Publisher ID according to store.
  publisherID: ID

  # Name of publisher, as defined on appstore.
  publisherName: String

  #
  publisherEmail: String

  #
  publisherAddress: String

  #
  publisherURL: URL

  #
  sellerName: String

  #
  supportURL: URL

  #
  latestReleaseNotes: String

  #
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  allRating: Float

  #
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  allRatingCount: Int

  #
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  currentRating: Float

  #
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  currentRatingCount: Int

  # Whether the application is a pack of stickers rather than a standalone app
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  isStickerApp: Boolean

  #
  id: ID! @deprecated(reason: "Use ref.")

  #
  package: String! @deprecated(reason: "Use packageKey.")

  #
  platform: PlatformEnum! @deprecated(reason: "Use platformType.")

  #
  publishedAppId: ID! @deprecated(reason: "Use appstoreApplicationKey.")

  #
  publishedAppID: ID! @deprecated(reason: "Use appstoreApplicationKey.")

  # List of all genres associated with the app.
  #
  # This information is generally available for both ios and android,
  # although the underlying categorization of genres is specific to each store.
  allGenres: [String!]

  # Expected size of app download, in bytes.
  #
  # Data is not generally available for android apps.
  downloadSize: Long

  # This gives a lower bound of numeric range, parsed from `downloadText` string.
  #
  # Data is not generally available for ios apps.
  minDownloadCount: Long

  # Raw string representing download count bucket, as shown by the store.
  #
  # Use `minDownloadCount` for a more useful, numeric value.
  downloadsText: String
}

# Entity representing each distinct package version observed for any given application
type IntelApplicationPackageVersion {
  #
  packageVersion: ID!

  #
  latestAnalysisRecordedAt: DateTime

  #
  initialAnalysisRecordedAt: DateTime

  #
  buildVersionKeys: [ID!]!

  # Resolves latest assessment on specified package version as of a specific point in time (defaulting to latest).
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  assessment(
    # Resolve latest application assessment as of a given point in time, given an ISO-8601 timestamp.
    asOf: String
  ): IntelAssessment
}

#
type IntelAssessment implements Assessment {
  # Distinct uuid of analysis results associated with this assessment in analysis log.
  ref: UUID!

  # Platform targeted by assessment (ios or android)
  platformType: PlatformEnum!

  # Package name (android) or bundle id string (iOS)
  packageKey: String!

  # Package name (android) or integer itunes id (iOS)
  appstoreApplicationKey: ID!

  # URL to application within platform's primary appstore.
  appstoreApplicationURL: String!

  # List distinct countries with which network traffic was detected.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  networkConnectionCountries: [Country!]

  # Version string uniquely identifying a specific application build.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  buildVersion: String!

  # Version string as defined by developer and packaged into build binary.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  packageVersion: ID

  # Release version as reported by appstore at time of download (often but not always identical to package version).
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  releaseVersion: String

  # When the assessment was recorded.
  createdAt: DateTime!

  # Name associated with publisher of application on appstore.
  #
  # - TODO
  #   - move this into child namespace for top level application metadata
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  publisherName: String

  # Application title associated with assessment, as rendered in report
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  title: String

  # Application icon associated with assessment, as rendered in report
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  iconURL: String

  # Analysis results for the assessment
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  analysis: IntelAssessmentAnalysis

  # Security score for assessment, generated from findings static and dynamic findings (when both are available).
  score: Float

  # Intel-specific assessment report.
  report: AssessmentReport

  # Compliance report
  evaluation(
    type: RegulatoryComplianceEvaluationType!
  ): RegulatoryComplianceEvaluation

  # Single context data found by a finding.
  findingContext(checkId: FindingCheckID!): FindingContext
    @deprecated(
      reason: "Use report.finding.context, evaluation.finding.context, etc."
    )

  # All context data found by the findings.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  findingContexts: [FindingContext!]

  # Whether or not build was downloaded directly from a public appstore.
  #
  # This is always true for IntelAssessment.
  isAppstoreDownload: Boolean!

  # Whether all analysis was created using our standard, baseline configuration.
  #
  # This is always true for IntelAssessment.
  hasBaselineConfig: Boolean!

  # Error code associated with assessment.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  errorCode: String

  # The PolicyVersion, if selected, the assessment is rendered with.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  policyVersion: PolicyVersion

  # Resolves the published application entity associated with this assessment.
  application: IntelApplication!
}

#
type IntelAssessmentAnalysis implements AssessmentAnalysis {
  # Analysis tasks
  task: IntelAnalysisTask!

  # True if both static and dynamic have completed successfully.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  isComplete: Boolean!

  # The error code associated with exception which occurred during analysis.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  errorCode: String
}

#
type IntelAnalysisTask {
  # Dynamic analysis details
  dynamic: IntelAnalysisJob

  # Static analysis details
  static: IntelAnalysisJob
}

#
type IntelAnalysisJob {
  # Last time the analysis job updated.
  #
  # Note: for intel data, represents time that analysis was recorded.
  modifiedAt: DateTime!

  # Status of the individual analysis job.
  status: String!

  # True if associated analysis tasks both for static and dynamic have completed successfully.
  isComplete: Boolean!

  # Raw result associated with analysis job.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  result: JSON
}

#
type IntegrationConfig {
  #
  jira: JiraIntegrationConfig

  #
  github: GithubIntegrationConfig

  #
  azure: AzureIntegrationConfig

  #
  gitlab: GitLabIntegrationConfig
}

#
type JiraIntegrationConfig implements ServiceIntegrationConfig {
  # A set of rules defining when tickets should be automatically created
  automationRules: IntegrationConfigAutomationRules

  # A URL confining this configuration to specific Jira instances
  baseUrl: URL

  #
  project: String

  #
  issueType: String

  #
  labels: [String!]

  #
  customFields: [JiraIntegrationCustomField!]

  #
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  issueTemplateMapping: IntegrationIssueTemplateMapping
}

#
interface ServiceIntegrationConfig {
  # A set of rules defining when tickets should be automatically created
  automationRules: IntegrationConfigAutomationRules
}

#
type IntegrationConfigAutomationRules {
  # A set of rules for which severities should have tickets automatically created
  severities: IntegrationConfigAutomationRulesSeverities

  # A set of rules for which policy categories should have tickets automatically created
  policyCategories: IntegrationConfigAutomationRulesPolicyCategories
}

#
type IntegrationConfigAutomationRulesSeverities {
  # Whether tickets should be automatically created for critical vulnerabilties
  critical: Boolean!

  # Whether tickets should be automatically created for high vulnerabilties
  high: Boolean!

  # Whether tickets should be automatically created for medium vulnerabilties
  medium: Boolean!

  # Whether tickets should be automatically created for low vulnerabilties
  low: Boolean!

  # Whether tickets should be automatically created for warn vulnerabilties
  warn: Boolean!

  # Whether tickets should be automatically created for info vulnerabilties
  info: Boolean!
}

#
type IntegrationConfigAutomationRulesPolicyCategories {
  # Whether tickets should be automatically created for category 1 vulnerabilities
  category1: Boolean!

  # Whether tickets should be automatically created for category 2 vulnerabilities
  category2: Boolean!

  # Whether tickets should be automatically created for category 3 vulnerabilities
  category3: Boolean!
}

#
type JiraIntegrationCustomField {
  #
  name: String!

  #
  value: String!

  #
  type: JiraIntegrationCustomFieldType
}

#
enum JiraIntegrationCustomFieldType {
  #
  string

  #
  number
}

# Describes a mapping between the issue template sections and issue field identifiers
type IntegrationIssueTemplateMapping {
  # The issue field identifier to which the title section of the issue template should be mapped
  title: String

  # The issue field identifier to which the finding description section of the issue template should be mapped
  description: String

  # The issue field identifier to which the steps to reproduce section of the issue template should be mapped
  reproduction: String

  # The issue field identifier to which the remediation resources section of the issue template should be mapped
  remediation: String

  # The issue field identifier to which the business impact section of the issue template should be mapped
  impact: String

  # The issue field identifier to which the risk and regulatory information section of the issue template should be mapped
  regulatory: String

  # The issue field identifier to which the application info section of the issue template should be mapped
  applicationInfo: String
}

#
type GithubIntegrationConfig implements ServiceIntegrationConfig {
  # A set of rules defining when tickets should be automatically created
  automationRules: IntegrationConfigAutomationRules

  #
  repository: String!

  #
  labels: [String!]
}

#
type AzureIntegrationConfig implements ServiceIntegrationConfig {
  # A set of rules defining when tickets should be automatically created
  automationRules: IntegrationConfigAutomationRules

  #
  organizationName: String!

  #
  projectId: UUID!

  # The work item type to create (defaults to "issue")
  workItemType: String

  #
  tags: [String!]

  #
  customFields: [AzureIntegrationCustomField!]

  #
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  issueTemplateMapping: IntegrationIssueTemplateMapping
}

#
type AzureIntegrationCustomField {
  # The Azure Work Item field name, "System.Title" or "Custom.CVSS" for example
  referenceName: String!

  # The datatype for this field. Defaults to "string"
  type: AzureIntegrationCustomFieldType

  # The value or substitution expression to send for this field
  value: String!
}

#
enum AzureIntegrationCustomFieldType {
  #
  string

  #
  number

  #
  boolean

  #
  datetime
}

#
type GitLabIntegrationConfig implements ServiceIntegrationConfig {
  # A set of rules defining when tickets should be automatically created
  automationRules: IntegrationConfigAutomationRules

  # GitLab group the project belongs to
  groupId: Int!

  # GitLab project to create issues on
  projectId: Int!

  # A list of labels to add to the created issues
  labels: [String!]
}

#
type AssessmentFindingAdjustmentAlertEvent implements IntegrationsAlertEvent {
  #
  id: Int!

  #
  eventType: IntegrationsAlertEventType!

  #
  createdAt: DateTime!

  #
  processedAt: DateTime

  #
  application: AutoApplication!

  #
  assessment: AutoAssessment!
}

#
type AppFindingAdjustmentAlertEvent implements IntegrationsAlertEvent {
  #
  eventType: IntegrationsAlertEventType!

  #
  createdAt: DateTime!

  #
  processedAt: DateTime

  #
  application: AutoApplication!
}

#
type FindingsQuery {
  # Enumerates the full set of findings currently tested for, optionally filtering by platform type
  #
  # - TODO
  #   - support filtering on other findings properties
  list(platformType: PlatformEnum): [FindingCheck!]!

  # Get a NIAP template by name or UUID ref.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  getNiapTemplate(name: String, ref: UUID): NiapTemplate

  # List NIAP templates.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  listNiapTemplates(includeArchived: Boolean): [NiapTemplate]!

  # Lists out reference data sources relevant for our findings calculations.
  reference: FindingsReferenceQuery
}

#
type NiapTemplate {
  # Unique (organization-wide) name to apply to template.
  name: String!

  #
  ref: UUID!

  #
  createdAt: DateTime!

  #
  updatedAt: DateTime

  #
  archivedAt: DateTime

  #
  createdBy: UUID

  #
  assertions: [NiapRequirementAssertion!]!
}

# Slowly-changing reference data relevant for our calculated findings.
type FindingsReferenceQuery {
  # Resolves list of android permissions, with optional filtering applied.
  android_permissions(
    # Filter for only the dangerous permissions.
    dangerous: Boolean

    # Optional glob string to filter down permission key strings to a relevant subset.
    #
    # Uses minimatch glob syntax.
    #
    # Example: All permissions starting with ACCESS: glob:"*.ACCESS*"
    glob: String
  ): [AndroidPermission!]!
}

# Definiton of an Android Permission record.
type AndroidPermission {
  # String used to identify a given android permission, e.g.:
  # - android.permission.ACCEPT_HANDOVER
  # - android.permission.ACCESS_FINE_LOCATION
  key: String!

  # This field will be true for known, documented android permissions.
  # It should only be false for permissions which we can be certain are custom.
  # In general, this should be null for any permissions unknown to the system.
  is_known: Boolean

  # For known permissions, this will be true when permission has "dangerous" protection level.
  is_dangerous: Boolean

  # Characterizes the potential risk implied in the permission and consists of a base type (normal, dangerous, signature) and zero or more flags, if any.
  #
  # [Android Protection Level Documentation](https://developer.android.com/reference/android/R.attr#protectionLevel)
  protection_level: [AndroidProtectionLevelEnum]

  # Summary extracted from documentation, if available.
  summary: String

  # Integer API level where permission was officially added, if any.
  api_added: Int

  # Integer API level where permission was officially deprecated, if any.
  api_deprecated: Int
}

#
enum AndroidProtectionLevelEnum {
  # Base permission type: a lower-risk permission that gives an application access to isolated application-level features, with minimal risk to other applications, the system, or the user.
  normal

  # Base permission type: a higher-risk permission that would give a requesting application access to private user data or control over the device that can negatively impact the user.
  dangerous

  # Base permission type: a permission that is managed internally by the system and only granted according to the protection flags.
  internal

  # Base permission type: a permission that the system is to grant only if the requesting application is signed with the same certificate as the application that declared the permission.
  signature

  # Additional flag: this permission can be automatically granted to the system app predictor.
  appPredictor

  # Additional flag: this permission is closely associated with an app op for controlling access.
  appop

  # Additional flag: this permission can be automatically granted to the system companion device manager service.
  companion

  # Additional flag: this permission automatically granted to device configurator
  configurator

  # Additional flag: this permission can also (optionally) be granted to development applications. Although undocumented, the permission state used to be shared by all users (including future users), but it is managed per-user since API level 31.
  development

  # Additional flag: this permission designates the app that will approve the sharing of incident reports.
  incidentReportApprover

  # Additional flag: this permission can be automatically granted to system apps that install packages.
  installer

  # Additional flag: this permission can be granted to instant apps
  instant

  # Additional flag: this permission can also be granted if the requesting application is signed by, or has in its signing lineage, any of the certificate digests declared in knownCerts.
  knownSigner

  # Additional flag: this permission can be granted only if its protection level is signature, the requesting app resides on the OEM partition, and the OEM has allowlisted the app to receive this permission by the OEM.
  oem

  # Additional flag: this permission can be automatically granted to apps that target API levels below Build.VERSION_CODES.M (before runtime permissions were introduced).
  pre23

  # Additional flag: this permission can be automatically granted any application pre-installed on the system image (not just privileged apps).
  preinstalled

  # Additional flag: this permission can also be granted to any applications installed as privileged apps on the system image. Please avoid using this option, as the signature protection level should be sufficient for most needs and works regardless of exactly where applications are installed.
  privileged

  # Additional flag: this permission will be granted to the recents app.
  recents

  # Additional flag: this permission will be granted to the retail demo app, as defined by the OEM.
  retailDemo

  # Additional flag: this permission is managed by role.
  role

  # Additional flag: this permission can only be granted to apps that target runtime permissions (Build.VERSION_CODES.M and above)
  runtime

  # Additional flag: this permission can be automatically granted to the setup wizard app
  setup

  # Additional flag: this permission can be automatically granted to the system default text classifier
  textClassifier

  # Additional flag: this permission can be granted to privileged apps in vendor partition.
  vendorPrivileged

  # Additional flag: this permission can be automatically granted to system apps that verify packages.
  verifier
}

#
type MyQuery {
  # Returns user entity for currently logged in user
  user: User!

  # Returns organization entity for currently logged in user
  organization: Organization!

  # Returns a list of tokens generated by the logged in user
  tokens(
    # Include revoked tokens in the list
    includeRevoked: Boolean

    # List tokens with names matching "search"
    search: String
  ): [Token!]

  # Returns group memberships for currently logged in user
  groups(active: Boolean): [AutoGroup!]!
}

#
type OrganizationQuery {
  # Internal helper to enumerate all organizations
  list(limit: Int = 100): [Organization!]!
}

#
type GroupQuery {
  # Resolve group by unique "name" string
  byName(
    #
    name: String!

    # Internal users can resolve any group by name within any org
    organizationId: Int
  ): AutoGroup

  # Resolve group by UUID entity ref
  byRef(ref: UUID!): AutoGroup
}

#
type UserQuery {
  # Resolve user by UUID ref.
  byRef(ref: UUID!, scope: String): User
}

#
#     The ApplicationRef is a subset of String used to uniquely identify applications. It has the form:
#
#     <prefix><separator><package key or application key>
#
#     where:
#
#     prefix is one of: ios, apple, itunes, android, google, play,
#
#     separator is a single or double colon. If it is a double colon the only permitted prefixes are ios and android, and,
#
#     the application ref must end with a package key or application key depending on the prefix:
#     apple: package key or application key
#     ios: package key
#     itunes: application key
#     google: package key
#     android: package key
#     play: package key.
#
#     Note package key = application key for Android.
#
scalar ApplicationRef

#
type PublishedApplication {
  # This is a unique identifier for a given published application.
  ref: ID!

  # Platform targeted by assessment (ios or android).
  platformType: PlatformEnum!

  # Package name (android) or bundle id string (iOS).
  packageKey: String!

  # Application key uniquely identifying application record on platform's default appstore.
  appstoreApplicationKey: ID!

  # Current published version, as surfaced within appstore.
  publishedVersion: String

  # Query over available package versions associated with application.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  packageVersions(
    # Max most recent package version to surface.
    limit: Int
  ): [IntelApplicationPackageVersion!]

  # Name of publisher, as defined on appstore.
  publisherName: String

  # Current application title, derived from latest published metadata.
  title: String!

  # Current application description
  description: String!

  # URL to application page on app store site.
  appstoreApplicationURL: URL!

  # Icon URL
  iconURL: URL

  # Screenshot URLs
  screenshotURLs: [URL!]

  # The date of the latest release. Format: YYYY-MM-DD
  latestReleaseDate: Date

  # Whether or not this application is free
  isFree: Boolean

  # Whether or not this application has been unpublished from app store.
  isUnpublished: Boolean

  # Whether or not this application is in a country NowSecure can scan.
  isAvailableInSupportedCountry: Boolean

  # Whether or not NowSecure can scan this application.
  isScannable: Boolean!

  # Date of recent result we have recorded any analysis of this application we have recorded in our analysis log.
  latestAnalysisRecorded: DateTime

  # For now this always returns null if user cannot see all analysis for a particular application,
  # and true otherwise, but this is not terribly coherent, and should probably change.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  isAnalysisAvailable: Boolean

  # Resolves latest application assessment as of a specific point in time (defaulting to latest).
  assessment(
    # Target a specific assessment for application by uuid ref.
    ref: UUID

    # Resolve latest application assessment as of a given point in time.
    asOf: String
  ): IntelAssessment
}

#
type IntelQuery {
  # Query for a single intel application.
  application(
    # Reference string to look up an application. Supports several syntaxes, e.g. platform:package (TODO document)
    ref: String!
  ): IntelApplication!

  # Query for a list of intel applications.
  applications(
    # Array of reference strings to look up applications.
    #
    # Supports a variety of uri-scheme-like syntaxes, e.g. platform:package
    refs: [String!]!
  ): [IntelApplication!]!

  #
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  searchApplications(
    # App store to search.
    platformType: PlatformEnum

    # Filter results by this search text.
    term: String!

    # Country app store to search (defaults to US).
    country: CountryID

    # Maximum applications to return.
    limit: Int

    # How many applications to skip.
    offset: Int

    #
    platform: PlatformEnum
  ): [IntelApplication!]!

  # Resolves most recent intel analysis results for specified application by build version.
  assessment(
    # The analysis log ref UUID representing a specific intel "assessment".
    ref: UUID!

    # The UUID ref of the PolicyVersion to use for rendering the assessment.
    policyVersionRef: UUID
  ): IntelAssessment

  # Resolves intel analysis results for given application by build version, as of a specific point in time (defaulting to latest).
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  latestBuildAssessment(
    # App platform type.
    platformType: PlatformEnum!

    # App package name or bundle id.
    packageKey: String!

    # Filter for specific app package version (developer-reported version as extracted from build binary).
    packageVersion: ID

    # Filter for specific build version (unique build identity as defined by intel).
    buildVersion: ID

    # Resolve build assessment with latest analyses as of a specific date.
    asOf: String
  ): IntelAssessment
}

# Application monitor type
type IntelApplicationMonitor {
  #
  requestRef: ID!

  #
  platformType: PlatformEnum!

  #
  applicationKey: String!

  #
  requestedAt: DateTime!

  #
  approvedAt: DateTime!

  #
  createdAt: DateTime!

  #
  expiresAt: DateTime

  #
  metadata: IntelApplication
}

#
type IntelUser {
  #
  id: ID!

  #
  name: String!

  #
  email: String!
}

#
type IntegrationQuery {
  # Get a list of the services that have been integrated
  services(
    # Filter integrations by service type
    type: IntegrationType

    # Filter for a specific integration
    ref: UUID

    # Filter integrations by authorization status
    status: IntegrationStatusType

    # List integrations in a chosen organization
    orgId: Int
  ): [Integration!]

  # Get a list of project scopes or groupings for an integration (e.g. the organizations or groups an integration has access to, if any)
  serviceIssueScopes(
    # The integration to list target scopes for
    ref: UUID!

    # If the service supports searching scopes, include a search term to filter on
    search: String

    # If the service supports querying for a particular scope, include its scope identifier
    scope: String
  ): [IntegrationTargetScope!]

  # Return a list of projects the specified integration can create issues on
  serviceIssueTargets(
    #
    ref: UUID!

    # If the service scopes projects by organization or group name, include the group or organization name as "scope"
    scope: String

    # If the service supports searching projects, include a search term to filter on
    search: String

    # If the service supports project metadata, provide a specific projectId to retreive its metadata
    projectId: String

    #
    includeMetadata: Boolean
  ): [IntegrationTarget!]

  # Return a list of issue types relevant to the specific scope and projectId
  serviceIssueTypes(
    #
    ref: UUID!

    # If the service requires scope to query issue types, include it
    scope: String

    # If the service requires projectId to query issue types, include it
    projectId: String
  ): [String!]

  # Return a list of issue labels relevant to the specific scope and projectId
  serviceIssueLabels(
    #
    ref: UUID!

    # If the service requires scope to query issue labels, include it
    scope: String

    # If the service requires projectId to query issue labels, include it
    projectId: String
  ): [String!]

  # Return a list of issue fields relevant to the specific scope and projectId
  serviceIssueFields(
    #
    ref: UUID!

    # If the service requires scope to query issue fields, include it
    scope: String

    # If the service requires projectId to query issue fields, include it
    projectId: String

    # If the service requires issueType to query issue fields, include it
    issueType: String

    # If the service allows us to determine the field's data type, optionally filter on it
    dataTypes: [String]
  ): [IntegrationIssueField!]

  # Returns a list of issues associated with the given appRef
  issues(
    # The UUID ref of the application to get issues for
    appRef: UUID!

    # An optional list of IntegrationTypes to filter on
    integrationTypes: [IntegrationType!]

    # An optional assessment UUID ref to only get issues relevant to the given asssessment
    assessmentRef: UUID
  ): [IntegrationIssue!]
}

#
enum IntegrationType {
  #
  jira

  #
  github

  #
  azure

  #
  gitlab
}

#
enum IntegrationStatusType {
  #
  initialized

  #
  authorizing

  #
  authorized
}

#
interface Integration {
  #
  ref: UUID!

  #
  type: IntegrationType!

  #
  version: Int!

  #
  status: IntegrationStatusType!

  #
  integrationName: String

  #
  name: IntegrationType!
    @deprecated(
      reason: "Use type for the integration type (jira, azure, etc.) or integrationName for the user defined integration name"
    )
}

# Describes the scope of projects an integration has access to in the target service (typically groups or organizations)
type IntegrationTargetScope {
  #
  identifier: String!

  #
  name: String!
}

# Describes potential targets for writing issues (Jira projects, GitHub repositories, Azure Boards, etc)
type IntegrationTarget {
  # The identifier for a target project/repo
  identifier: String!

  # Human-readable name for the target project/repo (may or may not be identical to identifier)
  name: String!

  # Additional metadata related to the project, if available
  metadata: JSON
}

#
type IntegrationIssueField {
  #
  identifier: String!

  #
  name: String!

  #
  required: Boolean!

  #
  description: String

  #
  dataType: String

  #
  defaultValue: JSON
}

# Represents our record of an issue that has been created in a third party integration
type IntegrationIssue {
  # The UUID ref of the integration issue
  ref: UUID!

  # The ref for the application associated with this issue
  appRef: UUID!

  # The finding check ID for the finding associated with this issue
  checkId: FindingCheckID!

  # The integration in which this issue was created
  integration: Integration

  # The type of the intgration this issue was created in
  integrationType: IntegrationType!

  # Identifies the scope/target in which this issue was created
  projectIdentifier: String

  # The integration specific identifier that was assigned to this issue inside the third party integration
  identifier: String

  # The status of the issue in the third party integration
  status: IntegrationIssueStatus

  # A URL to the issue's page inside the third party integration
  link: URL

  # The date the vulnerability associated with this issue was opened
  openedAt: DateTime

  # The date the vulnerability associated with this issue was closed
  closedAt: DateTime

  # The date this integration issue record was created
  createdAt: DateTime!

  # The date this integration issue record was last updated
  updatedAt: DateTime!

  # Whether or not this issue has been created in the third party integration
  created: Boolean!
}

#
type IntegrationIssueStatus {
  #
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  type: IntegrationIssueStatusType!

  #
  label: String!
}

#
enum IntegrationIssueStatusType {
  #
  unknown

  #
  todo

  #
  doing

  #
  done

  #
  deleted
}

#
type AutoQuery {
  # Takes an array of specified uuid assessment refs and returns an array of same length,
  # where each element corresponds to resolved AutoAssessment record.
  #
  # Requires: mygroup::auto.assessment:list
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  assessments(
    # Optionally filter for applications within specified set of uuid analysis group refs.
    groupRefs: [UUID!]

    # Specify a specific platform to resolve assessments for.
    platformType: PlatformEnum

    # Specify a list of assesment references to resolve.
    refs: [UUID!]

    # Maximum number of assessments to resolve.
    #
    # Note: we will eventually apply a default limit.
    limit: Int

    #
    scope: ID

    # Filter for assessments found to be affected by specific findings key.
    #
    # Note: also requires a limit to be specified.
    affectedByFindingKey: String

    # Filter for assessments with a specific status, e.g. status: 'completed'.
    status: String

    # Filter for assessments created >= creation date.
    since: DateTime

    # Filter for assessments created > creation date.
    after: DateTime

    # Filter for assessments created < creation date.
    before: DateTime

    # Filter for assessments created <= creation date.
    until: DateTime

    # Reverse sort order.
    reverse: Boolean

    # Optionally include all deleted assessments.
    includeDeleted: Boolean

    # Filter by default or custom config used.
    defaultConfig: Boolean

    # Filter assessments by the binary source.
    appstoreDownload: Boolean

    # Filter assessments by debug mode state.
    debugMode: Boolean

    # Filter assessments by favorite.
    favorite: Boolean
  ): [AutoAssessment]!

  # Resolve an individual assessment by UUID ref.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  assessment(
    # Unique assessment entity reference.
    ref: UUID

    # The UUID ref of the PolicyVersion to use for the assessment.
    policyVersionRef: UUID

    # Overrides the raw analysis inputs to use the given JSON object.
    _raw: JSON

    #
    scope: ID
  ): AutoAssessment

  # Returns the default analysis configuration
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  defaultAnalysisConfig: AnalysisConfigEntry

  # Takes an array of specified uuid app refs and returns an array of same length, where each element corresponds to resolved AutoApplication record.
  applications(
    # Optionally filter for applications within specified set of uuid app refs.
    refs: [UUID!]

    # Optionally filter for applications within specified set of uuid analysis group refs.
    groupRefs: [UUID!]

    # Maximum number of applications to resolve.
    #
    # Note: we will eventually apply a default limit.
    limit: Int

    # The offset for paging results in combination with limit
    offset: Int

    # Reverse sort order.
    reverse: Boolean

    # Optionally include all deleted assessments.
    includeDeleted: Boolean

    # Optionally filter for applications with one of a list of platform types.
    platformTypes: [PlatformEnum!]

    # Optionally filter for applications with one of a list of package keys.
    packageKeys: [String!]

    #
    scope: ID

    #
    groups: [UUID!]
  ): [AutoApplication]!

  #
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  application(
    # Unique application entity reference.
    ref: UUID!

    #
    scope: ID
  ): AutoApplication

  # Returns the historical list of changes for any given application by uuid app ref.
  #
  # TODO: ultimately we will hang this off any given Application node
  applicationHistory(ref: UUID!): [AutoApplicationHistoryEntry!]!

  # Returns the set of changes to mutable application properties over *every* application within the organization.
  #
  # This is an org-wide capability, and as such, is restricted to org admins only.
  applicationsAuditLog(
    after: DateTime
    until: DateTime
  ): [AutoApplicationHistoryEntry!]!
    @deprecated(reason: "should use audit.changes instead")

  #
  analysisEvents(assessmentRefs: [UUID!], refs: [UUID!]): [AnalysisEvent!]

  # Enuemrate builds available to user.
  builds(
    # Optional filter for builds within specified set of build refs.
    refs: [UUID!]

    # Optional filter for builds within specified set of groups.
    groupRefs: [ID!]

    # Optional filter for builds within specified app.
    appRef: ID

    # Maximum number of builds to resolve.
    limit: Int

    # Reverse sort order.
    reverse: Boolean
  ): [AutoBuild!]

  # Resolve an individual build
  build(ref: UUID!): AutoBuild!

  #
  findingExpressions(
    appIds: [UUID!]
    checkIds: [FindingCheckID!]
    attributeName: String
  ): [FindingExpression!]

  # Resolve a list of groups by UUID group refs
  groups(refs: [UUID!]!): [AutoGroup!]

  # List projects, optionally by project or group UUID ref
  projects(refs: [UUID!], groupRef: UUID): [Project!]

  # Get a list of project files in a named collection (e.g. "reports", "binaries", etc.)
  #
  # - One of 'projectRef' or 'groupRef' is required
  # - collectionName: one of "report", "artifact", "binary", or "*"
  projectFiles(
    groupRef: UUID
    projectRef: UUID
    projectType: ProjectTypeEnum
    collectionName: String
    collectionNames: [String]
    platformType: PlatformEnum
    packageKey: String
    latest: Boolean
  ): [ProjectFile!]

  #
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  historicalStats(
    # Specify a default period to aggregate over, e.g. day, week, month, year (defaulting to day)
    period: String = "day"

    # Filter specifically for stats on assessments of builds downloaded from appstore vs. uploaded by user
    buildSourceType: BuildSourceType

    # Filter for just the stats of a given platform (defaulting to all platforms)
    platform: PlatformEnum

    # Specify a subset of groups to aggregate over
    groups: [UUID!]

    # When to start aggregation statistics
    startAt: DateTime
  ): [AutoStatsHistoricalPeriodAggregate!]!

  #
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  policy: PolicyQuery!
}

#
type AutoApplicationHistoryEntry {
  #
  historyRef: UUID!

  #
  historyBaseRef: UUID!

  #
  historyChangedFields: [String!]!

  #
  historyTimestamp: DateTime!

  #
  groupRef: UUID!

  #
  appTitle: String

  #
  staticConfigDefault: JSON

  #
  staticAnalysisDisabled: Boolean

  #
  dynamicConfigDefault: JSON

  #
  dynamicAnalysisDisabled: Boolean

  #
  integrationConfig: IntegrationConfig

  #
  findingsOverrides: JSON

  #
  archivedAt: DateTime

  #
  testRunnerBinary: String

  #
  appstoreApplicationKey: String

  #
  updatedBy: UUID
}

#
type FindingExpression {
  #
  appId: UUID

  #
  checkId: FindingCheckID

  #
  attributeName: String!

  #
  expression: String!

  #
  errors: [FindingExpressionError!]
}

#
type FindingExpressionError {
  #
  message: String!

  #
  createdAt: DateTime!
}

#
type Project {
  #
  ref: UUID!

  #
  projectType: ProjectTypeEnum

  #
  groupRef: UUID! @deprecated(reason: "Use group.ref")

  #
  group: AutoGroup

  #
  name: String!

  #
  notes: String

  #
  status: ProjectStatusEnum!

  #
  archived: Boolean!

  #
  createdAt: DateTime!

  #
  updatedAt: DateTime!

  #
  binary: ProjectFile
    @deprecated(
      reason: "Use projectFiles(collectionName: \"pentest_binary\", projectRef: \"...\", latest: true) instead"
    )

  #
  report: ProjectFile
    @deprecated(
      reason: "Use projectFiles(collectionName: \"pentest_report\", projectRef: \"...\", latest: true) instead"
    )

  #
  library: [ProjectFile!]
    @deprecated(
      reason: "Use projectFiles(collectionName: \"pentest_library\", projectRef: \"...\") instead"
    )
}

#
enum ProjectTypeEnum {
  #
  pentest

  #
  automation

  #
  support

  #
  workstation
}

#
enum ProjectStatusEnum {
  #
  submitted

  #
  received

  #
  inProgress

  #
  completed
}

#
type ProjectFile {
  #
  ref: UUID

  #
  project: Project

  #
  uploadedBy: String

  #
  collectionName: String

  #
  filename: String!

  #
  contentType: String

  #
  byteSize: Int

  #
  createdAt: DateTime!

  #
  tags: JSON

  #
  downloadUrl: String
}

#
enum BuildSourceType {
  #
  upload

  #
  store
}

#
type AutoStatsHistoricalPeriodAggregate {
  #
  groupingKey: [ID]!

  #
  periodicPartitionKey: ID!

  #
  periodicTotalAssessmentCount: Int!

  #
  periodicCompletedAssessmentCount: Int!

  #
  periodicCurrentAssessmentCount: Int!

  #
  periodicCancelledAssessmentCount: Int!

  #
  periodicOverallFindingsTestCount: Int!

  #
  periodicOverallFindingsRiskCount: Int!

  #
  periodicCurrentFindingsTestCount: Int!

  #
  periodicCurrentFindingsRiskCount: Int!

  #
  cumulativeUniqueApplicationCount: Int!

  #
  cumulativeOverallApplicationCount: Int!

  #
  cumulativeTotalAssessmentCount: Int!

  #
  cumulativeOverallFindingsTestCount: Int!

  #
  cumulativeOverallFindingsRiskCount: Int!

  #
  cumulativeCurrentFindingsTestCount: Int!

  #
  cumulativeCurrentFindingsRiskCount: Int!

  #
  cumulativeCurrentApplicationScoreMean: Float

  #
  cumulativeOverallApplicationScoreMean: Float
}

#
type PolicyQuery {
  # Gets the default NowSecure Policy, the policy used if none other is specified
  getDefaultPolicy: Policy!

  # Gets a specific policy by its UUID ref
  getPolicy(
    # The UUID ref of the policy to get
    ref: UUID!
  ): Policy

  # Gets all available policies
  listPolicies: [Policy!]!

  # Returns a PolicyVersionChanges object describing the changes from the policy version identified by policyVersionARef to the policy version identified by policyVersionBRef
  comparePolicyVersions(
    # UUID ref of the policy version to start the comparison at
    policyVersionARef: UUID!

    # UUID ref of the policy version to compare against the policy version identified by policyVersionARef
    policyVersionBRef: UUID!
  ): PolicyVersionChanges!
}

# Describes the changes from the policy version identfied by policyVersionARef to policy version identfied by policyVersionBRef
type PolicyVersionChanges {
  # UUID ref of the policy version to start the comparison at
  policyVersionARef: UUID!

  # UUID ref of the policy version to compare against the policy version identified by policyVersionARef
  policyVersionBRef: UUID!

  # Changes to the policy's findings
  findings: [PolicyVersionChange]!

  # Changes to the policy's regulations
  regulations: [PolicyVersionChange]!

  # Changes to the policy's policyCategories
  policyCategories: [PolicyVersionChange]!
}

# Describes a single change within a policy version
type PolicyVersionChange {
  # The key in the parent object that saw a change
  key: String!

  # The type of the change that occurred
  type: PolicyVersionChangeType!

  # The value before the change, where appropriate (UPDATE or REMOVE)
  oldValue: JSON

  # The value after the change, where appropriate (ADD or UPDATE)
  newValue: JSON
}

# The type of change within a policy version
enum PolicyVersionChangeType {
  #
  ADD

  #
  UPDATE

  #
  REMOVE
}

#
type AuditQuery {
  # Returns a set of activity log events over the given (optional) time interval, additionally allowing a limit to be specified.
  changes(
    #
    since: String

    #
    until: String

    #
    limit: Int

    # Filter for only those changes associated with any of the entity types specified.
    entityTypes: [EntityType!]

    # Filter for only those changes associated with attributes specified.
    attributes: [String!]

    # Filter for only those changes associated with entity refs specified.
    entityRefs: [UUID!]
  ): [ChangeActivity!]!
}

#
enum EntityType {
  # Top-level organization entity.
  ORGANIZATION

  # A registered user entity associated with organization.
  USER

  # Long-lived token entity associated with a specific user (e.g. for scripted interactions with API).
  TOKEN

  # Invitation entity for a new user to join org (with associated metadata like groups, roles).
  INVITATION

  # Top-level org-centric "master" app entity, allowing control over what constitutes equivalence of distinct application packages.
  ORG_APP

  # Represents a given access control group entity within organization.
  GROUP

  # Low-level entity representing a specific app package within an analysis group, each of which is associated with its own distinct analysis history.
  APP

  # Build entity associates a given app binary with a specific access control group.
  BUILD

  # Assessment request entity, associating related static and/or dynamic analysis tasks.
  ASSESSMENT

  # Represents platform's record of an issue created in an integration.
  INTEGRATION_ISSUE

  # Represents an integrated service.
  INTEGRATION

  # Represents an uploaded file.
  UPLOAD

  # Represents a policy
  POLICY

  # Represents a policy version
  POLICY_VERSION
}

#
type ChangeActivity {
  # Enumeration defining the type of entity associated with change event.
  entityType: EntityType!

  # Global identifier of entity associated with change event.
  entityRef: UUID!

  # Attribute on associated entity which was affected by change event.
  attribute: String!

  # Bare value (as JSON) which was associated with change event.
  value: JSON

  # System wall clock time recorded for change event.
  updatedAt: DateTime!

  # User associated with change activity, if any (e.g. user responsible for initiating system action leading to change).
  user: User

  #
  updatedBy: UUID @deprecated(reason: "Use user.ref")
}

# Global metadata queries, e.g. data on specific countries.
type GlobalQuery {
  #
  countries(
    # Filter countries that are in the store for this platform.
    platform: PlatformEnum
  ): [Country!]!
}

# Raw iTunes-specific endpoint helpers.
type ItunesQuery {
  # Search for any iOS app using iTunes App Store endpoint directly, as if searching from an iPad device.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  search(
    term: String!
    limit: Int = 50
    country: CountryID
  ): [ItunesAppSearchResult!]!
}

# Raw search result record from [iTunes search endpoint](https://affiliate.itunes.apple.com/resources/documentation/itunes-store-web-service-search-api/).
type ItunesAppSearchResult {
  #
  bundleId: String!

  #
  isGameCenterEnabled: Boolean

  #
  screnshotUrls: [URL!]

  #
  ipadScreenshotUrls: [URL!]

  #
  appletvScreenshotUrls: [URL!]

  #
  trackContentRating: String

  #
  trackId: ID

  #
  trackName: String

  #
  trackCensoredName: String

  #
  primaryGenreId: ID

  #
  genreID: [ID!]

  #
  formattedPrice: String

  #
  primaryGenreName: String

  #
  isVppDeviceBasedLicensingEnabled: Boolean

  #
  releaseDate: DateTime

  #
  minimumOsVersion: String

  #
  sellerName: String

  #
  currentVersionReleaseDate: DateTime

  #
  releaseNotes: String

  #
  currency: String

  #
  version: String

  #
  wrapperType: String

  #
  artistId: ID

  #
  artistName: String

  #
  genres: [String!]

  #
  price: Float

  #
  description: String

  #
  averageUserRating: Float

  #
  userRatingCount: Int

  #
  artworkUrl60: URL

  #
  artworkUrl512: URL

  #
  artworkUrl100: URL

  #
  artistViewUrl: URL

  #
  supportedDevices: [String!]

  #
  languageCodesISO2A: [String!]

  #
  fileSizeBytes: String

  #
  sellerUrl: URL

  #
  contentAdvisoryRating: String

  #
  averageUserRatingForCurrentVersion: Float

  #
  userRatingCountForCurrentVersion: Int

  #
  trackViewUrl: URL
}

# NowSecure System queries
type SystemQuery {
  # NowSecure system status query
  status: SystemStatusQuery!

  # Query legacy vmatrix source for job status records
  _legacyJobStatusList(limit: Int): [_LegacyJobStatus!]
    @deprecated(reason: "use system.loderunner")

  # Query legacy consul source for device health check records
  _legacyDeviceHealthCheckList(
    platform: PlatformEnum
    limit: Int
  ): [_LegacyDeviceHealthCheck!] @deprecated(reason: "use system.dms")

  #
  dms: DeviceManagementSystemQuery

  #
  loderunner: LoderunnerSystemQuery

  #
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  queue: QueueSystemQuery!
}

# Query system status
type SystemStatusQuery {
  #
  overall: SystemStatusItem!

  #
  domains: [SystemDomainStatus!]!

  #
  incidents: [JSON!]!

  #
  maintenance: SystemMaintenanceStatusQuery
}

#
interface SystemStatusItem {
  #
  updated: DateTime!

  #
  status: String!

  #
  status_code: Int!
}

#
type SystemDomainStatus implements SystemStatusItem & Node {
  #
  id: ID!

  #
  name: String!

  #
  updated: DateTime!

  #
  status: String!

  #
  status_code: Int!

  #
  containers: [SystemContainerStatus!]!
}

#
interface Node {
  #
  id: ID!
}

#
type SystemContainerStatus implements SystemStatusItem & Node {
  #
  id: ID!

  #
  name: String!

  #
  updated: DateTime!

  #
  status: String!

  #
  status_code: Int!
}

#
type SystemMaintenanceStatusQuery {
  #
  active: [JSON!]!

  #
  upcoming: [JSON!]!
}

# Legacy vmatrix device status record
type _LegacyJobStatus implements Node {
  #
  id: ID!

  #
  type: String!

  #
  submittedAt: DateTime

  #
  scheduledAt: DateTime

  #
  startTime: DateTime

  #
  endTime: DateTime

  #
  status: String!

  #
  requestId: ID

  #
  priority: String

  #
  errorCode: ID

  #
  _params: JSON

  #
  _emsg: String
}

# Legacy device health check record
type _LegacyDeviceHealthCheck implements Node {
  #
  id: ID!

  #
  service: ID!

  #
  platform: PlatformEnum!

  #
  status: _LegacyDeviceHealthCheckStatusEnum!

  #
  name: String

  #
  output: String

  #
  notes: String
}

#
enum _LegacyDeviceHealthCheckStatusEnum {
  #
  passing

  #
  warning

  #
  critical
}

#
type DeviceManagementSystemQuery {
  #
  devices(filter: DeviceQueryCriteria): [Device]
}

#
input DeviceQueryCriteria {
  #
  page: Int

  #
  pageSize: Int

  #
  deviceId: String

  #
  name: String

  #
  dataCenter: String

  #
  platform: SystemPlatformEnum

  #
  model: String

  #
  osVersion: String

  #
  kind: DeviceEventType

  #
  supportsSms: Boolean

  #
  supportsSim: Boolean

  #
  capabilities: String
}

# Platform defines IOS/ANDROID of device
enum SystemPlatformEnum {
  #
  ANDROID

  #
  IOS
}

#
enum DeviceEventType {
  #
  ADDED

  #
  REMOVED

  #
  UPDATED

  #
  ENABLED

  #
  DELETED

  #
  DISABLED

  #
  REGISTERED

  #
  UNREGISTERED

  #
  ALLOCATED

  #
  DEALLOCATED

  #
  HEALTH

  #
  JAILBREAK

  #
  JOB_STARTED

  #
  JOB_ENDED

  #
  SCREENSHOT

  #
  APPS_LIST

  #
  APPS_RUNNING

  #
  APP_INSTALL

  #
  APP_UNINSTALL

  #
  RESTART

  #
  COMMAND

  #
  PROVISION
}

#
type Device {
  #
  deviceId: String

  #
  name: String

  #
  dataCenter: String

  #
  platform: SystemPlatformEnum

  #
  description: String

  #
  model: String

  #
  osVersion: String

  #
  bricked: Boolean

  #
  jailbreak: Boolean

  #
  timezone: String

  #
  hostname: String

  #
  capabilities: String

  #
  jobName: String

  #
  appKey: String

  #
  appVersion: String

  #
  requestId: Int

  #
  supportsSms: Boolean

  #
  supportsSim: Boolean

  #
  requiresMaintenance: Boolean

  #
  enabled: Boolean

  #
  registered: Boolean

  #
  allocated: Boolean

  #
  healthStatus: String

  #
  healthInfo: String

  #
  hardwareInfo: String

  #
  registeredAt: DateTime

  #
  allocatedAt: DateTime

  #
  lastJailbreakAt: DateTime

  #
  lastRebootedAt: DateTime
}

#
type LoderunnerSystemQuery {
  #
  jobsQuery(
    filter: LoderunnerJobsQueryCriteria
    pagination: LoderunnerPagination
    order: LoderunnerSortOrder
  ): LoderunnerJobsResult
}

#
input LoderunnerJobsQueryCriteria {
  #
  requestId: Long

  #
  requestKey: String

  #
  dateSpan: String

  #
  username: String

  #
  jobName: String

  #
  taskName: String

  #
  statuses: [LoderunnerJobRequestStatus]

  #
  priority: Int

  #
  category: String

  #
  platform: SystemPlatformEnum

  #
  group: String

  #
  errorCode: String

  #
  since: Long
}

#
enum LoderunnerJobRequestStatus {
  #
  PENDING

  #
  STARTED

  #
  EXECUTING

  #
  STOPPED

  #
  COMPLETED

  #
  FAILED

  #
  UNKNOWN
}

#
input LoderunnerPagination {
  #
  page: Int

  #
  pageSize: Int
}

#
input LoderunnerSortOrder {
  #
  orderBy: [OrderBy]
}

#
input OrderBy {
  #
  field: OrderByField

  #
  ascending: Boolean
}

#
enum OrderByField {
  #
  id

  #
  username

  #
  priority

  #
  jobName

  #
  status

  #
  submittedAt

  #
  scheduledAt

  #
  updatedAt
}

#
type LoderunnerJobsResult {
  #
  page: Int

  #
  pageSize: Int

  #
  totalRecords: Long

  #
  totalPages: Long

  #
  jobs: [LoderunnerJob]

  #
  since: Long
}

#
type LoderunnerJob {
  #
  requestId: Long

  #
  requestKey: String

  #
  jobName: String

  #
  jobExecutionId: Long

  #
  status: LoderunnerJobRequestStatus

  #
  username: String

  #
  category: String

  #
  group: String

  #
  priority: Int

  #
  platform: SystemPlatformEnum

  #
  platformModel: String

  #
  platformOSVersion: String

  #
  capabilities: String

  #
  startTime: DateTime

  #
  endTime: DateTime

  #
  scheduledTime: DateTime

  #
  createdTime: DateTime

  #
  updatedTime: DateTime

  #
  submittedTime: DateTime

  #
  errorCode: String

  #
  timezone: String

  #
  cancelable: Boolean

  #
  restartable: Boolean

  #
  jobRetries: Int

  #
  stoppable: Boolean

  #
  duration: String

  #
  tasks: [LoderunnerTask]

  #
  failureExceptions: [Throwable]

  #
  jobParameters: [KeyValue]

  #
  executionContext: [KeyValue]
}

#
type LoderunnerTask {
  #
  taskId: Long

  #
  taskName: String

  #
  status: String

  #
  exitStatus: String

  #
  startTime: DateTime

  #
  endTime: DateTime

  #
  failureExceptions: [Throwable]

  #
  executionContext: [KeyValue]
}

#
type Throwable {
  # Error message
  message: String
}

#
type KeyValue {
  # Key name
  key: String

  # Stringified value
  value: String
}

#
type QueueSystemQuery {
  #
  jobByRef(ref: UUID!): QueueSystemJob

  #
  taskByRef(ref: UUID!): QueueSystemTask
}

#
type AssessmentJobSummary {
  #
  task_id: Long!

  #
  assessment_id: String!

  #
  platform: PlatformEnum!

  #
  status: AssessmentJobSummaryStatus!

  #
  account_id: String!

  #
  application_key: String!

  #
  job_type: String!

  #
  error_code: String

  #
  tasks: [AssessmentTaskSummary]
}

#
enum AssessmentJobSummaryStatus {
  #
  pending

  #
  completed

  #
  failed

  #
  cancelled
}

#
type AssessmentTaskSummary {
  #
  id: String!

  #
  status: AssessmentJobSummaryStatus!

  #
  display_task_type: String!

  #
  display_name: String!

  #
  execution_order: Int!

  #
  optional: Boolean!

  #
  emsg: String

  #
  task_type: String!

  #
  error_code: String
}

# QueueSystemJob is used as output job when a job is queued for lode-runner jobs
type QueueSystemJob {
  #
  jobRef: UUID!

  #
  loderunnerRequestID: Long

  #
  platform: String

  #
  jobType: String!

  #
  jobStatus: String!

  #
  jobParams: String

  #
  jobContext: String

  #
  jobPriority: Int!

  #
  applicationKey: String

  #
  versionString: String

  #
  versionCode: String

  #
  orgID: String

  #
  username: String

  #
  errorCode: String

  #
  emsg: String

  #
  createdAt: DateTime!

  #
  updatedAt: DateTime!
}

# QueueSystemTask represents task in the job workflow
type QueueSystemTask {
  #
  taskRef: UUID!

  #
  jobRef: UUID!

  #
  loderunnerTaskID: Long

  #
  taskType: String!

  #
  taskStatus: String!

  #
  taskSource: String

  #
  taskContext: String

  #
  taskResult: String

  #
  errorCode: String

  #
  emsg: String

  #
  createdAt: DateTime!

  #
  updatedAt: DateTime!
}

# Collection of mixrank queries.
type RawMetadataQuery {
  #
  appVersionDownload(
    platformType: PlatformEnum!
    pname: String!
    versionCode: Int!
    limit: Int = 50
  ): [AppVersionDownload]

  #
  appMetadata(
    platformType: PlatformEnum!
    pname: String!
    limit: Int = 50
  ): AppMetadata
}

# Application download information based on a specific version
type AppVersionDownload {
  #
  id: Int

  #
  byteSize: Int

  #
  sha256: String

  #
  sha1: String

  #
  name: String

  #
  namespaceCount: Int

  #
  downloadAt: DateTime

  #
  permissionCount: Int

  #
  versionCode: Int

  #
  md5: String

  #
  s3uri: String

  #
  appId: Int

  #
  dsid: Float

  #
  has2fa: Boolean

  #
  userCountry: String

  #
  uri: String

  #
  binUri: String

  #
  classdumpUri: String

  #
  plistUri: String

  #
  rawIpa: String

  #
  buyproductResponse: String

  #
  sinf: String

  #
  createdAt: DateTime

  #
  versionString: String
}

# App metadata
type AppMetadata {
  #
  score: Float

  #
  title: String

  #
  versionCode: String

  #
  versionString: String

  #
  latestVersion: Int

  #
  majorVersionNumber: Int

  #
  removed: Boolean

  #
  isFree: Boolean

  #
  nativePrice: Float

  #
  nativeCurrency: String

  #
  convertedPrice: Float

  #
  convertedCurrency: String

  #
  formattedPrice: String

  #
  releaseDate: Date

  #
  pname: String

  #
  smallArtworkUrl: String

  #
  largeArtworkUrl: String

  #
  xlargeArtworkUrl: String

  #
  contentRating: String

  #
  is32bitOnly: Boolean

  #
  vendor: String

  #
  companyId: Int

  #
  companyUrl: String

  #
  artistName: String

  #
  artistId: Int

  #
  releaseNotes: String

  #
  description: String

  #
  appId: Int

  #
  privacyPolicyUrl: String

  #
  languages: [String]

  #
  copyright: String

  #
  priceAmount: Float

  #
  priceString: String

  #
  createdAt: DateTime

  #
  itunesLink: String

  #
  countryId: String

  #
  configsCount: Int

  #
  reviewCount: Int

  #
  seller: String

  #
  minDownloadCount: Long

  #
  rating: Float

  #
  ratings: JSON

  #
  ratingCount: Int

  #
  installationSize: Long

  #
  developerId: Int

  #
  developerEmail: String

  #
  developerName: String

  #
  developerWebsite: String

  #
  hasInAppPurchase: Boolean

  #
  descriptionHtml: String

  #
  configCount: Int

  #
  largeIconUrl: String

  #
  smallIconUrl: String

  #
  promoBannerUrl: String

  #
  screenshots: [String]

  #
  supportUrl: String

  #
  minIosVersion: Int

  #
  requirementString: String

  #
  category: String

  #
  categories: [String]

  #
  categoryId: Int

  #
  categoryIds: [Int]

  #
  supportedDevices: [String]

  #
  permissions: [String]

  #
  versions: [AppVersion]

  #
  images: [AppImage]

  #
  ipadScreenshotUrls: [String]

  #
  screenshotUrls: [String]

  #
  iaps: [InAppPurchases]
}

# Application version information
type AppVersion {
  #
  versionDisplay: String

  #
  id: Int

  #
  downloaded: Boolean

  #
  isLatest: Boolean

  #
  releaseDate: Date

  #
  releaseNotes: String

  #
  assetSize: Int

  #
  resourceCount: Int

  #
  classCount: Int

  #
  configCount: Int

  #
  hasx86: Boolean

  #
  errors: [String]
}

# Application image information
type AppImage {
  #
  url: String

  #
  type: JSON

  #
  firstSeen: Date

  #
  lastSeen: Date
}

# In app purchase information for iOS applications
type InAppPurchases {
  #
  id: Int

  #
  name: String

  #
  price: String
}

#
type FeatureFlagQuery {
  #
  getFeatureFlag(featureId: String!): FeatureFlag

  #
  getLicenseFlag(licenseId: LicenseIdentifier): [LicenseFlag]
}

#
type FeatureFlag {
  #
  id: String!

  #
  value: String
}

#
enum LicenseIdentifier {
  #
  masvs_flag
}

#
type LicenseFlag {
  #
  id: LicenseIdentifier!

  #
  value: String
}

# NowSecure graph mutation endpoints
type Mutation {
  #
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  alerts: AlertsMutation!

  #
  organization: OrganizationMutation

  #
  # ---
  #
  # ğŸ›¡ï¸ ** ORG ADMIN ** ğŸ›¡ï¸
  group: GroupMutation

  #
  # ---
  #
  # ğŸ›¡ï¸ ** ORG ADMIN ** ğŸ›¡ï¸
  user: UserMutation

  #
  findings: FindingsMutation

  #
  integration: IntegrationMutation!

  #
  auto: AutoMutation!
}

#
type AlertsMutation {
  #
  patchGroupAlertPolicy(
    ref: UUID!
    input: GroupAlertPolicyInput!
  ): GroupAlertPolicy!

  #
  setAlertRead(id: Int!): Int!

  #
  setAllAlertsRead: [Int!]!
}

#
input GroupAlertPolicyInput {
  #
  email: GroupEmailAlertPolicyInput

  #
  events: AlertPoliciesInput
}

#
input GroupEmailAlertPolicyInput {
  #
  sendToDefaultAddresses: Boolean

  #
  otherAddresses: [String!]

  #
  isSignInRequired: Boolean

  #
  isDigestEnabled: Boolean

  #
  digestFrequency: AlertFrequencyInput
}

#
input AlertFrequencyInput {
  #
  value: Int!

  #
  unit: AlertFrequencyUnitEnum!
}

#
input AlertPoliciesInput {
  #
  appConfigUpdated: AppConfigUpdatedAlertPolicyInput

  #
  appStale: AppStaleAlertPolicyInput

  #
  assessmentDone: AssessmentDoneAlertPolicyInput

  #
  findingsUpdated: FindingsUpdatedAlertPolicyInput
}

#
input AppConfigUpdatedAlertPolicyInput {
  #
  deliveryChannels: [AlertDeliveryChannelEnum!]
}

#
input AppStaleAlertPolicyInput {
  #
  deliveryChannels: [AlertDeliveryChannelEnum!]

  #
  interval: AlertFrequencyInput
}

#
input AssessmentDoneAlertPolicyInput {
  #
  deliveryChannels: [AlertDeliveryChannelEnum!]

  #
  onEveryAssessment: Boolean

  #
  onIncompleteOrFailed: Boolean

  #
  onScore: Boolean

  #
  maximumScore: Int

  #
  onVulnerabilities: Boolean

  #
  vulnerabilities: [String!]

  #
  onNewVulnerabilities: Boolean

  #
  onNetworkConnectionCountries: Boolean

  #
  networkConnectionCountries: [CountryID!]
}

#
input FindingsUpdatedAlertPolicyInput {
  #
  deliveryChannels: [AlertDeliveryChannelEnum!]
}

#
type OrganizationMutation {
  # Create a role
  createRole(label: String!, description: String): Role!

  # Organization invitation
  # ---
  #
  # ğŸ›¡ï¸ ** ORG ADMIN ** ğŸ›¡ï¸
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  createUserInvitation(
    name: String
    email: String!
    roleName: String!
    groupRefs: [UUID!]!
    expiresIn: Int
  ): UserInvitation

  # Revoke Organization invitation
  # ---
  #
  # ğŸ›¡ï¸ ** ORG ADMIN ** ğŸ›¡ï¸
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  revokeUserInvitation(ref: UUID!): UserInvitation

  # Remove a role
  removeRole(ref: UUID!): Boolean!

  # Reset a role to default settings and permissions (system-defined permissions for built-in roles, no permissions for custom roles)
  resetRole(ref: UUID!): Role!

  # Set the label used for a role
  updateRole(ref: UUID!, label: String): Role!

  # Grant a permission to a role
  grantPermission(
    # The role to grant the permission to
    roleRef: UUID!

    # The permission to grant to this role
    permissionRef: UUID!
  ): Role!

  # Revoke a permission from a role
  revokePermission(
    # The role to revoke the permission from
    roleRef: UUID!

    # The permission to revoke from this role
    permissionRef: UUID!
  ): Role!

  # Revoke a token generated by a user in your org
  revokeToken(
    # The token id to revoke
    ref: UUID!

    # The ID of the user that owns the token
    userRef: UUID!
  ): Token!

  #
  associateAppstoreApplication(
    # Reference string to look up an application
    ref: String!
  ): OrganizationApplication!
}

#
type OrganizationApplication {
  #
  organizationId: Int!

  # Unique identifier for the application
  ref: UUID!

  # Platform targeted by the application
  platformType: PlatformEnum!

  # Package name (android) or bundle id string (iOS)
  packageKey: String!

  # Appstore key
  appstoreApplicationKey: String

  # The ref of the user who last updated this application
  updatedBy: UUID

  # "
  # Current application title
  title: String
}

# Operations to change a given group entity within an organization.
type GroupMutation {
  # Set max concurrent jobs for a specific group entity, or null to use org-default value.
  # Return value reflects updated settings value.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  setMaxJobsConcurrency(
    # UUID group ref representing group to manage setting on.
    groupRef: ID!

    # Value to use for concurrency setting.
    value: Int
  ): Int

  #
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  setGroupAssessmentSourceFilter(
    # UUID group ref representing group to manage setting on.
    groupRef: ID!

    # The source (app store vs uploads, or both) by which to filter assessment lists in this group
    value: GroupAssessmentSourceType!
  ): Setting!

  #
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  setGroupAssessmentLicenseFilter(
    # UUID group ref representing group to manage setting on.
    groupRef: ID!

    # The license type (advanced, baseline, or both) by which to filter assessment lists in this group
    value: GroupAssessmentLicenseType!
  ): Setting!

  # Set note field on a given group entity, or null to remove.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  setNote(
    # Value to set for note field, or null to remove.
    value: String

    #
    groupRef: ID!
  ): String
}

#
enum GroupAssessmentSourceType {
  #
  appstore

  #
  uploaded

  #
  both
}

#
enum GroupAssessmentLicenseType {
  #
  baseline

  #
  advanced

  #
  both
}

# Operations to change a given user entity within an organization.
type UserMutation {
  # Set note field on a given user entity, or null to remove.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  setNote(
    # Value to set for note field, or null to remove.
    value: String

    #
    userRef: ID!
  ): String
}

#
type FindingsMutation {
  #
  _links: JSON @deprecated(reason: "unused")

  # Create or update a NIAP template by its name.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  setNiapTemplate(
    name: String!
    assertions: [NiapAssertionInput!]!
  ): NiapTemplate

  # Archive NIAP template by name or UUID ref.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  archiveNiapTemplate(
    # String name of template.
    name: String

    # UUID ref of template.
    ref: UUID
  ): NiapTemplate
}

#
input NiapAssertionInput {
  #
  id: FindingCheckID!

  #
  data: JSON!
}

#
type IntelMutation {
  #
  _links: JSON

  # For requesting analysis on an application within intel
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  requestAnalysis(
    # Reference ID for an application. Supports several syntaxes, e.g. platform:package
    ref: ID!

    # Optional version code (android-only for now) representing specific version to analyze
    versionCode: ID

    # Whether the user is notified when the analysis is complete
    notify: Boolean
  ): IntelAnalysisRequest

  # For requesting that intel start monitoring an application
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  requestApplicationMonitor(
    # App reference, e.g. "platform:package", or "appstore:appstore_application_key"
    ref: ID!
  ): IntelApplicationMonitor

  # For requesting that intel start monitoring a list of applications
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  requestApplicationMonitors(
    # An array of app references, e.g. "platform:package", or "appstore:appstore_application_key"
    refs: [ID!]!
  ): IntelApplicationMonitorsResponse!
}

# Selection type for IntelMutation.requestAnalysis
type IntelAnalysisRequest {
  #
  ref: UUID!
}

# Selection type for requestIntelApplicationMonitors. Allows for returning the successful monitors
# along with a list of error messages
type IntelApplicationMonitorsResponse {
  #
  applicationMonitors: [IntelApplicationMonitor!]!

  #
  errors: [IntelApplicationMonitorError!]!
}

# A type describing an error for an intel application monitor request
type IntelApplicationMonitorError {
  #
  requestRef: ID!

  #
  message: String!
}

#
type IntegrationMutation {
  # Adds the named type of integration to the organization
  addIntegration(
    # The type of integration to add
    type: IntegrationType!

    # Any integration type dependent settings that are required
    settings: CreateIntegrationInput

    # The name to assign to the integration. If there already exists an integration of this type, the name is required, otherwise it is optional
    name: EntityName

    # The Platform UI client that is adding the integration
    client: IntegrationClient = legacy
  ): Integration!

  # Edit properties of the integrated service
  editIntegration(
    # A reference to the integrated service to edit
    ref: UUID!

    # Pass in to rename the integration
    name: EntityName
  ): Integration!

  # Remove the referenced integration from the organization
  removeIntegration(ref: UUID!): Boolean!

  # Initiates an OAuth exchange to authorize a connection between NowSecure and the destination service
  requestAuthorization(
    # Ref of the integration to request authorization for.
    ref: UUID!

    # Optional callback URL passed to the ticketing integration when authorization is requested. Only supported for Jira integrations.
    callbackUrl: URL
  ): IntegrationAuthorizationRequest!

  # Finalizes the OAuth exchange with the service. When this is successful the integration is complete
  finishAuthorization(ref: UUID!, state: String!, code: String!): Integration!

  # Creates an issue for the assessment + affected finding on the specified integration
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  createIssue(
    # A reference to the integrated service to use to create the issue
    ref: UUID!

    # The assessment to use for the issue
    assessmentRef: UUID!

    # The finding to create an issue for
    findingCheckId: FindingCheckID!

    # IntegrationConfig to use for the issue. Omit this to use the configuration that is currently saved for the app
    configuration: IntegrationConfigInput

    # Debug mode (default=false). When enabled (true) createIssue will attempt to create the issue and will not de-duplicate or record the issue for future de-duplication.
    # If debug mode is false or omitted, the issue will only be created if there is not a record of it already.
    debug: Boolean
  ): IntegrationCreateIssueResult!

  # Unregisters (should they exist) and re-registers the integration's webhooks
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  reregisterWebhooks(
    # A reference to the integrated service to use for reregistering the webhooks
    ref: UUID!

    # The orgId for the organization the integration defined by "ref" belongs to
    orgId: Int
  ): [IntegrationWebhook!]

  # Requests the current status of all the integration's issues and brings them up to date. Returns the IntegrationIssues that have received updates
  syncIssues(
    # A reference to the integrated service to use for syncing the issues
    ref: UUID!

    # The orgId for the organization the integration defined by "ref" belongs to
    orgId: Int
  ): [IntegrationIssue!]
}

#
input CreateIntegrationInput {
  # Base URL for a Jira integration (e.g. "https://my-company-jira.atlassian.net")
  baseUrl: String
}

#
enum IntegrationClient {
  #
  legacy

  #
  rainier
}

#
type IntegrationAuthorizationRequest {
  # URL to redirect to for authorization
  url: String!
}

#
input IntegrationConfigInput {
  #
  jira: JiraIntegrationConfigInput

  #
  github: GithubIntegrationConfigInput

  #
  azure: AzureIntegrationConfigInput

  #
  gitlab: GitLabIntegrationConfigInput
}

#
input JiraIntegrationConfigInput {
  # A set of rules defining when tickets should be automatically created
  automationRules: IntegrationConfigAutomationRulesInput!

  # A URL to confine this configuration to a specific Jira instance
  baseUrl: URL

  # Numeric project ID to create issues on
  project: String!

  # The issue type for each created issue. Defaults to "Task"
  issueType: String

  # Labels to add to each created issue
  labels: [String!]

  # Custom fields to add to each created issue
  customFields: [JiraIntegrationCustomFieldInput!]

  # Optional bespoke mapping
  issueTemplateMapping: IntegrationIssueTemplateMappingInput
}

#
input IntegrationConfigAutomationRulesInput {
  # A set of rules for which severities should have tickets automatically created
  severities: IntegrationConfigAutomationRulesSeveritiesInput

  # A set of rules for which policy categories should have tickets automatically created
  policyCategories: IntegrationConfigAutomationRulesPolicyCategoriesInput
}

#
input IntegrationConfigAutomationRulesSeveritiesInput {
  # Whether tickets should be automatically created for critical vulnerabilties
  critical: Boolean!

  # Whether tickets should be automatically created for high vulnerabilties
  high: Boolean!

  # Whether tickets should be automatically created for medium vulnerabilties
  medium: Boolean!

  # Whether tickets should be automatically created for low vulnerabilties
  low: Boolean!

  # Whether tickets should be automatically created for warn vulnerabilties
  warn: Boolean!

  # Whether tickets should be automatically created for info vulnerabilties
  info: Boolean!
}

#
input IntegrationConfigAutomationRulesPolicyCategoriesInput {
  # Whether tickets should be automatically created for category 1 vulnerabilities
  category1: Boolean!

  # Whether tickets should be automatically created for category 2 vulnerabilities
  category2: Boolean!

  # Whether tickets should be automatically created for category 3 vulnerabilities
  category3: Boolean!
}

#
input JiraIntegrationCustomFieldInput {
  # Name of the custom  field (e.g. customfield_123)
  name: String!

  # Value for the custom field
  value: String!

  # Type of value to send. Almost always "string", but in some cases Defaults to "string" if not set. Set to "number" to send a number to JIRA (instead of a string containing a number)
  type: JiraIntegrationCustomFieldType
}

# Describes a mapping between the issue template sections and issue field identifiers
input IntegrationIssueTemplateMappingInput {
  # The issue field identifier to which the title section of the issue template should be mapped
  title: String

  # The issue field identifier to which the finding description section of the issue template should be mapped
  description: String

  # The issue field identifier to which the steps to reproduce section of the issue template should be mapped
  reproduction: String

  # The issue field identifier to which the remediation resources section of the issue template should be mapped
  remediation: String

  # The issue field identifier to which the business impact section of the issue template should be mapped
  impact: String

  # The issue field identifier to which the risk and regulatory information section of the issue template should be mapped
  regulatory: String

  # The issue field identifier to which the application info section of the issue template should be mapped
  applicationInfo: String
}

#
input GithubIntegrationConfigInput {
  # A set of rules defining when tickets should be automatically created
  automationRules: IntegrationConfigAutomationRulesInput!

  # github repository to create issues on, formatted as "organization/repo"
  repository: String!

  # A list of labels to add to any issues created in github
  labels: [String!]
}

#
input AzureIntegrationConfigInput {
  # A set of rules defining when tickets should be automatically created
  automationRules: IntegrationConfigAutomationRulesInput!

  # The name of the organization (within Azure) the project belongs to
  organizationName: String!

  # The project ID to create work items on
  projectId: UUID!

  # The work item type to create (defaults to "issue")
  workItemType: String

  #
  tags: [String!]

  # Optional custom fields to populate on work created items.
  customFields: [AzureIntegrationCustomFieldInput!]

  # Optional bespoke mapping
  issueTemplateMapping: IntegrationIssueTemplateMappingInput
}

#
input AzureIntegrationCustomFieldInput {
  # The Azure Work Item field name, such as "System.Title" or "Custom.CVSS"
  referenceName: String!

  # The value or substitution expression for the field
  value: String!

  # The datatype of the field. Defaults to "string" if not set
  type: AzureIntegrationCustomFieldType
}

#
input GitLabIntegrationConfigInput {
  # A set of rules defining when tickets should be automatically created
  automationRules: IntegrationConfigAutomationRulesInput!

  # GitLab group the project belongs to
  groupId: Int!

  # GitLab project to create issues on
  projectId: Int!

  # A list of labels to add to the created issues
  labels: [String!]
}

#
type IntegrationCreateIssueResult {
  # Whether or not the issue was created as a result of calling the createIssue mutation
  created: Boolean!

  # The Platform record of the ticketing integration issue
  issue: IntegrationIssue
}

#
type IntegrationWebhook {
  # The identifier for this webhook within the 3rd party integration
  identifier: String!

  # The project identifier for this webhook within the 3rd party integration
  projectIdentifier: String

  #
  createdAt: DateTime!

  #
  updatedAt: DateTime!
}

#
type AutoMutation {
  # Adjusts a finding by its checkId, on the requested application and/or assessment(s)
  adjustFinding(
    # The UUID ref of the application to adjust (or of the application the assessments being adjusted beolong to)
    applicationRef: UUID!

    # Finding Check Identifier
    checkId: FindingCheckID!

    # Adjustment to make
    input: FindingAdjustmentInput!

    # Applies the adjustment to the given assessment and existing future ones
    fromAssessmentRef: UUID

    # When true, all existing assessments for the given applicationRef are adjusted
    adjustAllExistingAssessments: Boolean

    # Applies the adjustment to each of the given assessments
    assessmentRefs: [UUID!]

    # When true, adjusts the application so future assessments inherit this adjustment
    adjustAllFutureAssessments: Boolean
  ): [AssessmentReportAdjustment]!

  #
  adjustApplicationFindings(
    # Unique application reference
    ref: UUID!

    # Findings Check Identifier
    checkId: FindingCheckID!

    # Adjustments to make
    input: FindingAdjustmentInput!
  ): [AssessmentReportAdjustment!]!

  #
  adjustAssessmentFinding(
    # Unique application reference
    ref: UUID!

    # Findings Check Identifier
    checkId: FindingCheckID!

    # Adjustments to make
    input: FindingAdjustmentInput!
  ): AssessmentReportAdjustment!

  # Create a finding expression
  setFindingExpression(
    #
    appId: UUID

    #
    checkId: FindingCheckID

    # Attribute name, must be a valid identifier. The result of the expression becomes available during substitution. If the
    # attribute name is "risk", the value is available via `{ derived.risk }`
    attributeName: String!

    # A simple javascript expression to be evaluated in a findings context. The
    # finding and assessment values are globals when the expression is evaluated
    expression: String!
  ): FindingExpression!

  #
  removeFindingExpression(
    #
    appId: UUID

    #
    checkId: FindingCheckID

    # Attribute name, must be a valid identifier
    attributeName: String!
  ): Boolean!

  #
  createProject(
    name: String!
    projectType: ProjectTypeEnum
    groupRef: UUID!
    notes: String
  ): Project!

  #
  updateProject(
    ref: UUID!
    name: String
    notes: String
    archived: Boolean
    status: ProjectStatusEnum
  ): Project!

  #
  requestDeletion(targetType: String!, targetRef: UUID!): DeletionRequest!

  #
  confirmDeletion(
    targetType: String!
    targetRef: UUID!
    requestRef: UUID!
  ): DeletionRequest

  #
  setApplicationIntegrationConfig(
    appRef: UUID!
    jira: JiraIntegrationConfigInput
    github: GithubIntegrationConfigInput
    azure: AzureIntegrationConfigInput
    gitlab: GitLabIntegrationConfigInput
  ): IntegrationConfig

  #
  setApplicationTitle(
    # The app identifier to set a custom title for
    appRef: UUID!

    # The title to use. Use null or an empty string to use the default title parsed from the application binary
    title: String
  ): AutoApplication

  #
  setBuildVersion(
    # UUID reference to a specific build entity.
    ref: ID!

    # The specific version key to use for the give build. This value *should* be [semver 2.0](https://semver.org/spec/v2.0.0.html) compatible, but any string will be accepted.
    value: String
  ): AutoBuild

  # Set default analysis configuration settings to use by default when running an assessment for the specified application.
  #
  # Only those top level arguments which are specified will overwrite their associated values within the analysis config.
  #
  # TODO this should be refactored to return an AnalysisConfigEntry type reflecting the edited config in final form
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  setApplicationAnalysisConfig(
    # Application reference by UUID.
    appRef: UUID!

    #
    configTemplateName: String

    # Specify lists of action strings to find or avoid.
    actions: AnalysisConfigActionsInput

    # Specify properties for specific sensitive data types (specify searchStrings, toggle isSensitive).
    #
    # TODO:
    # * enumerate list of known data value types
    # * surface explicit mutation hooks for each well-known sensitive data type recognized by system
    searchData: [AnalysisConfigSearchDataInput!]

    # Specify searchStrings for custom search terms.
    searchTerms: [AnalysisConfigSearchTermInput!]

    # API test parameters, e.g. enable active API testing against a given list of URLs.
    api: AnalysisConfigApiInput

    # Configure Appium runner.
    appium: AnalysisConfigAppiumRunnerInput

    # Configure XCTest runner (ios).
    xctest: AnalysisConfigXcTestRunnerInput

    # Configure Espresso runner (android).
    espresso: AnalysisConfigEspressoRunnerInput

    # e.g. "onPermissionRequest(function (request) {  ..."
    jsScript: String

    #
    dslScript: String

    #
    dslScriptFilename: String

    # Control resigning configuration.
    resigning: AnalysisConfigResigningInput

    # Puts application into an experimental new "debug mode", where dynamic anlysis will fail fast for better ergonomics while developing scripts.
    failfast: Boolean
  ): JSON

  #
  updateAssessmentNiapRequirementAssertions(
    ref: UUID!
    assertions: [NiapAssertionInput!]!
  ): AutoAssessment

  # Sets the favorite field of the given assessment to the provided favorite value.
  setAssessmentFavorite(
    # The UUID ref of the assessment to favorite or unfavorite.
    assessmentRef: UUID!

    # The favorite value to assign to the assessment.
    favorite: Boolean!
  ): AutoAssessment!

  #
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  policy: PolicyMutation!
}

#
input FindingAdjustmentInput {
  # Set affected flag for the assessment, "null" = remove affected override
  affected: Boolean

  # Set cvss for the assessment, "null" = remove cvss override
  cvss: Float

  # Set "true" to hide finding for all assessment for the application, "null" to remove hidden override
  hidden: Boolean

  # Add a note for the assessment, "null" = remove note
  note: String

  # Add a short piece of summary text
  shortRemediation: String
}

#
type AssessmentReportAdjustment {
  # Unique reference to the assessment that was modified
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  assessmentRef: UUID!

  # Score generated from findings, if exists
  score: Float

  # When the report was generated
  createdAt: DateTime!

  # Reflects the findings checkId which was targeted within the mutation.
  checkId: FindingCheckID!

  # The adjusted findings
  findings: [Finding!]!
}

# Requests to delete data
type DeletionRequest {
  #
  ref: UUID!

  #
  targetType: String!

  #
  targetRef: UUID!

  #
  createdBy: UUID!

  #
  createdAt: DateTime!

  #
  confirmedBy: UUID

  #
  confirmedAt: DateTime
}

#
type PotentialNewAppReleaseResponse {
  #
  recordedAt: DateTime!
}

#
input AnalysisConfigActionsInput {
  #
  find: [String!]!

  #
  avoid: [String!]
}

#
input AnalysisConfigSearchDataInput {
  #
  key: String!

  #
  value: String!

  #
  nonSensitive: Boolean = false

  #
  searchStrings: [String!]!
}

#
input AnalysisConfigSearchTermInput {
  #
  name: String!

  #
  value: String!

  #
  searchStrings: [String!]!
}

# API testing configuration to set.
input AnalysisConfigApiInput {
  # Explicit list of URLs to enable active API testing against.
  activeTestingList: [String!]!
}

#
input AnalysisConfigAppiumRunnerInput {
  # Filename representive of appium runner, e.g. "my-appium-test.py"
  runnerFilename: String!

  # Either node, python or python3
  interpreter: AppiumInterpreter!

  # Optional command to run before analysis
  setupCommand: String

  # Provide optional additional arguments to the appium script
  args: [String!]

  # Optionally set environment variables
  env: [AppiumEnvVarInput!]

  # The original filename of the uploaded archive
  archiveFilename: String

  # Sha256 checksum of previously uploaded file, or, the full URL of the previously uploaded file
  code: String
}

#
input AppiumEnvVarInput {
  # The identifier for the environment variable
  identifier: String!

  # The value for the environment variable
  value: String!
}

#
input AnalysisConfigXcTestRunnerInput {
  #
  functionName: String

  #
  runnerFilename: String
}

#
input AnalysisConfigEspressoRunnerInput {
  #
  runnerPackagename: String!

  #
  testClasses: [String!]

  #
  runnerFilename: String
}

#
input AnalysisConfigResigningInput {
  #
  disable: Boolean!
}

#
type PolicyMutation {
  # Creates a new policy
  createCustomPolicy(
    # The name of the policy
    name: EntityName!

    # The contents of the policy. This must only override findings and regulations defined in latest version of the policy identified by trackedPolicyRef
    policy: PolicyInput!

    # The type of entities the UUID refs in targetEntityRefs identify
    targetEntityType: PolicyTargetEntityType

    # The list of UUID refs for the entities this policy applies to
    targetEntityRefs: [UUID!]

    # The UUID ref of the policy to track. This must identify a NowSecure managed policy
    trackedPolicyRef: UUID!

    # Optionally track a specific policy version. If not provided, the latest version is tracked.
    trackedPolicyVersion: Int

    # Whether the policy is on or off
    enabled: Boolean = true

    # Whether to move any conflicting target entity refs in targetEntityRefs from their current policy to this one
    moveConflictingTargetEntityRefs: Boolean = false

    # An optional textual note describing the policy's content
    note: Note
  ): Policy!

  # Updates an existing policy
  updateCustomPolicy(
    # The UUID ref of the policy to update
    ref: UUID!

    # If specified, the new name of the policy
    name: EntityName

    # A list of PolicyFindingInputs, each describing the policy's overidden behaviour for a finding. If not defined, and
    # at least one of regulations and policyCategories are defined, the findings values from the previous policy version are taken.
    findings: [PolicyFindingInput!]

    # A list of PolicyRegulationInputs, each describing the policy's preferences for a regulation. If not defined, and
    # at least one of findings and policyCategories are defined, the regulations values from the previous policy version are taken.
    regulations: [PolicyRegulationInput!]

    # A list of PolicyCategoryInputs, each describing the policy's overrides for a policy category. If not defined, and
    # at least one of findings and regulations are defined, the policyCategories values from the previous policy version are taken.
    policyCategories: [PolicyCategoryInput!]

    # The type of entities the UUID refs in targetEntityRefs identify
    targetEntityType: PolicyTargetEntityType

    # If specified, the new list of UUID refs for the entities this policy applies to. If targetEntityRefs is non-empty, targetEntityType must also be defined
    targetEntityRefs: [UUID]

    # Whether the policy is on or off
    enabled: Boolean

    # Whether to move any conflicting target entity refs in targetEntityRefs from their current policy to this one
    moveConflictingTargetEntityRefs: Boolean = false

    # An optional textual note describing the changes made to the policy's content
    note: Note
  ): Policy!

  # Sets the organization policy to the NowSecure Default Policy.
  setOrganizationPolicyToDefault: Policy!

  # Updates a NowSecure Managed Policy
  updateNSManagedPolicy(
    # The UUID ref of the NowSecure Manged Policy to update
    ref: UUID!

    # The type of entity this policy applies to. If this value is being changed, either the existing targetEntityRefs must be empty or targetEntityRefs
    # must also be cleared or changed with this operation
    targetEntityType: PolicyTargetEntityType

    # If specified, the new list of UUID refs for the entities this policy applies to. If targetEntityRefs is non-empty, targetEntityType must also be defined
    targetEntityRefs: [UUID]

    # Whether the policy is on or off
    enabled: Boolean

    # Whether to move any conflicting target entity refs in targetEntityRefs from their current policy to this one
    moveConflictingTargetEntityRefs: Boolean = false
  ): Policy!

  # Sets the archive status for a custom policy.
  #
  # If archiving a policy with targets, forceArchive must be set to true for the operation to succeed
  setCustomPolicyArchived(
    # The UUID ref of the custom policy to archive
    ref: UUID!

    # When true, the policy is archived, when false, the policy in unarchived
    archived: Boolean!

    # When archiving a policy with targets, forceArchive must be set to true for the operation to succeed
    forceArchive: Boolean = false
  ): Policy!

  # Updates the mutable properties of a specific custom policy version.
  updateCustomPolicyVersion(
    # The UUID ref of the custom policy version to update.
    ref: UUID!

    # A textual note describing the policy version's content.
    note: Note
  ): PolicyVersion!

  # Updates a custom policy's tracked version. This should be used to resolve "upstream" changes from a NowSecure managed policy into a custom policy.
  updateCustomPolicyTrackedVersion(
    # The UUID ref of the custom policy to update.
    policyRef: UUID!

    # The new version of the tracked policy.
    newTrackedVersion: Int!

    # The contents of the new custom policy.
    #
    # NB: If not provided the latest policy version is used.
    policy: PolicyInput
  ): Policy!

  # For the given application, sets the given policy as the active policy.
  setApplicationPolicy(
    # Identifies the application to set the active policy for.
    applicationRef: UUID!

    # Identifies the policy to set as the active policy for the application.
    policyRef: UUID!
  ): Policy!
}

#
input PolicyInput {
  # A list of PolicyFindingInputs, each describing the policy's overidden behaviour for a finding
  findings: [PolicyFindingInput!]!

  # A list of PolicyRegulationInputs, each describing the policy's preferences for a regulation
  regulations: [PolicyRegulationInput!]!

  # A list of PolicyCategoryInputs, each describing the policy's overrides for a policy category
  policyCategories: [PolicyCategoryInput!]!
}

#
input PolicyFindingInput {
  # Identifier for the finding check affected by these overrides
  checkId: FindingCheckID!

  # Whether the finding should be shown in reports, and used for derived data like scores
  hidden: Boolean!

  # The policy category this finding should be sorted into if affected
  policyCategory: PolicyCategoryInteger!

  # The CVSS score for this finding
  cvss: CVSSScore

  # The CVSS vector for this finding
  cvssVector: CVSSVector
}

#
input PolicyRegulationInput {
  # Identifier for the regulation these preferences are for
  regulation: RegulatoryTypeEnum!

  # Whether this regulation is available for targeted entities
  enabled: Boolean!
}

#
input PolicyCategoryInput {
  # The policy category these overrides apply to
  policyCategory: PolicyCategoryInteger!

  # A label for the policy category
  label: EntityName!

  # A short description for the policy category
  description: EntityDescription

  # A color used by UI referencing this category
  color: HexColor!
}

# NowSecure System mutations
type SystemMutation {
  #
  _links: JSON

  #
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  queue: QueueSystemMutation!
}

#
type QueueSystemMutation {
  #
  createJob(job: QueueSystemJobInput!): QueueSystemJob!

  #
  createTask(task: QueueSystemTaskInput!): QueueSystemTask!

  #
  updateJob(ref: UUID!, job: QueueSystemJobUpdate!): QueueSystemJob!

  #
  updateTask(ref: UUID!, task: QueueSystemTaskUpdate!): QueueSystemTask!
}

# QueueSystemJobInput is used to create lode-runner job
input QueueSystemJobInput {
  #
  platform: String

  #
  jobType: String!

  #
  jobParams: String

  #
  jobPriority: Int

  #
  applicationKey: String

  #
  versionString: String

  #
  versionCode: String

  #
  orgID: String

  #
  username: String
}

# QueueSystemTaskInput is used to create a new lode-runner task
input QueueSystemTaskInput {
  #
  jobRef: UUID!

  #
  taskType: String!

  #
  taskStatus: String

  #
  taskSource: String
}

# QueueSystemJobUpdate is used to update lode-runner jobs
input QueueSystemJobUpdate {
  #
  loderunnerRequestID: Long!

  #
  platform: String

  #
  jobStatus: String!

  #
  jobContext: String

  #
  applicationKey: String

  #
  versionString: String

  #
  versionCode: String

  #
  errorCode: String

  #
  emsg: String
}

# QueueSystemTaskUpdate is used to update a lode-runner task
input QueueSystemTaskUpdate {
  #
  loderunnerTaskID: Long!

  #
  taskStatus: String!

  #
  taskContext: String

  #
  taskResult: String

  #
  errorCode: String

  #
  emsg: String
}

# NowSecure graph subscription endpoints
type Subscription {
  # Subscribe to analysis screenshots for an assessment. All screenshots are pushed on connection.
  # ---
  #
  # ğŸ”¥ **EXPERIMENTAL** ğŸ”¥
  autoAssessmentAnalysisScreenshots(
    assessmentRef: UUID!
    sortBy: AnalysisScreenshotSortField
  ): [AnalysisScreenshot!]!
}

#
type IntelPartialFindingsCalculationResult {
  # Intel analysis log ref UUID
  ref: ID!

  # Error message emitted by db, if calculation failed
  error: String
}

#
type IntelAssessmentHistoryItem {
  #
  sortKey: ID!

  #
  recordedAt: DateTime

  #
  assessment: IntelAssessment!
}

#
type AutoAssessmentHistoryItem {
  #
  sortKey: ID!

  #
  recordedAt: DateTime

  #
  assessment: AutoAssessment!
}

#
type IntegrationIssueSubscriptionEvent implements SubscriptionEvent {
  # The entityType of INTEGRATION_ISSUE for IntegrationIssueSubscriptionEvents
  entityType: SubscriptionEntityType!

  # The UUID ref of the integration issue associated with the subscription event
  entityRef: UUID!

  # The event type of the subscription event
  eventType: SubscriptionEventType!

  # The time at which the subscription event occured
  timestamp: DateTime!

  # The integration issue associated with the subscription event
  issue: IntegrationIssue
}

#
interface SubscriptionEvent {
  #
  entityType: SubscriptionEntityType!

  #
  entityRef: UUID!

  #
  eventType: SubscriptionEventType!

  #
  timestamp: DateTime!
}

#
enum SubscriptionEntityType {
  #
  INTEGRATION_ISSUE
}

#
enum SubscriptionEventType {
  #
  ADD

  #
  UPDATE

  #
  REMOVE
}

# A time string at UTC, such as 10:15:30Z, compliant with the `full-time` format outlined in section 5.6 of the RFC 3339profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
scalar Time

# The Email scalar type represents E-Mail addresses compliant to RFC 822.
scalar Email

#
enum AppBuildFormatType {
  # android .apk file
  apk

  # iOS .ipa file
  ipa
}

#
interface AlertEvent {
  #
  id: Int!
}

#
type AppConfigUpdatedAlertEvent implements AlertEvent {
  #
  id: Int!

  #
  appId: UUID!

  #
  appHistoryRef: UUID!
}

#
type AppConfigUpdatedAlert implements Alert {
  #
  id: Int!

  #
  eventType: String!

  #
  deliveryChannel: AlertDeliveryChannelEnum!

  #
  createdAt: DateTime!

  #
  readAt: DateTime

  #
  event: AppConfigUpdatedAlertEvent!

  #
  policy: AppConfigUpdatedAlertPolicy!
}

#
type AppStaleAlertEvent implements AlertEvent {
  #
  id: Int!

  #
  appId: UUID!

  #
  lastAssessmentId: UUID!

  #
  lastAssessedAt: DateTime!
}

#
type AppStaleAlert implements Alert {
  #
  id: Int!

  #
  eventType: String!

  #
  deliveryChannel: AlertDeliveryChannelEnum!

  #
  createdAt: DateTime!

  #
  readAt: DateTime

  #
  event: AppStaleAlertEvent!

  #
  policy: AppStaleAlertPolicy!
}

#
type AssessmentDoneAlertEvent implements AlertEvent {
  #
  id: Int!

  #
  appId: UUID!

  #
  assessmentId: UUID!

  # The assessment associated with the AssessmentDoneAlertEvent, should the user have permission to access it.
  assessment: AutoAssessment

  #
  status: String!

  #
  score: Int

  #
  vulnerabilities: [String!]

  #
  newVulnerabilities: [String!]

  #
  networkConnectionCountries: [CountryID!]
}

#
type AssessmentDoneAlert implements Alert {
  #
  id: Int!

  #
  eventType: String!

  #
  deliveryChannel: AlertDeliveryChannelEnum!

  #
  createdAt: DateTime!

  #
  readAt: DateTime

  #
  event: AssessmentDoneAlertEvent!

  #
  policy: AssessmentDoneAlertPolicy!
}

#
type FindingsUpdatedAlertEvent implements AlertEvent {
  #
  id: Int!

  #
  vulnerabilities: [String!]
}

#
type FindingsUpdatedAlert implements Alert {
  #
  id: Int!

  #
  eventType: String!

  #
  deliveryChannel: AlertDeliveryChannelEnum!

  #
  createdAt: DateTime!

  #
  readAt: DateTime

  #
  appIds: [UUID!]

  #
  event: FindingsUpdatedAlertEvent!

  #
  policy: FindingsUpdatedAlertPolicy!
}

#
enum GroupAssessmentFilterType {
  #
  licenseType

  #
  sourceType
}

# Integration level GitHub settings
type GithubIntegrationSettings {
  #
  scope: String

  #
  client: IntegrationClient!
}

# Integration level JIRA settings
type JiraIntegrationSettings {
  #
  publicKey: String!

  #
  consumerKey: String!

  #
  consumerName: String!

  #
  baseUrl: String!

  #
  client: IntegrationClient!
}

# Integration level Azure Settings
type AzureBoardsIntegrationSettings {
  #
  scope: String

  #
  client: IntegrationClient!
}

# Integration level GitLab Settings
type GitLabIntegrationSettings {
  #
  scope: String

  #
  client: IntegrationClient!
}

#
type JiraIntegration implements Integration {
  #
  ref: UUID!

  #
  type: IntegrationType!

  #
  version: Int!

  #
  status: IntegrationStatusType!

  #
  integrationName: String

  #
  settings: JiraIntegrationSettings!

  #
  name: IntegrationType!
    @deprecated(
      reason: "Use type for the integration type (jira, azure, etc.) or integrationName for the user defined integration name"
    )
}

#
type GithubIntegration implements Integration {
  #
  ref: UUID!

  #
  type: IntegrationType!

  #
  version: Int!

  #
  status: IntegrationStatusType!

  #
  integrationName: String

  #
  settings: GithubIntegrationSettings!

  #
  name: IntegrationType!
    @deprecated(
      reason: "Use type for the integration type (jira, azure, etc.) or integrationName for the user defined integration name"
    )
}

#
type AzureBoardsIntegration implements Integration {
  #
  ref: UUID!

  #
  type: IntegrationType!

  #
  version: Int!

  #
  status: IntegrationStatusType!

  #
  integrationName: String

  #
  settings: AzureBoardsIntegrationSettings!

  #
  name: IntegrationType!
    @deprecated(
      reason: "Use type for the integration type (jira, azure, etc.) or integrationName for the user defined integration name"
    )
}

#
type GitLabIntegration implements Integration {
  #
  ref: UUID!

  #
  type: IntegrationType!

  #
  version: Int!

  #
  status: IntegrationStatusType!

  #
  integrationName: String

  #
  settings: GitLabIntegrationSettings!

  #
  name: IntegrationType!
    @deprecated(
      reason: "Use type for the integration type (jira, azure, etc.) or integrationName for the user defined integration name"
    )
}

#
type AutoStatsCurrentAggregate {
  # Counts unique applications by package name/bundle id across groups
  uniqueApplicationCount: Int!

  # Counts total application instances by group
  totalApplicationCount: Int!

  #
  totalAssessmentCount: Int!

  #
  completedAssessmentCount: Int!

  # Counts total requested assessments which have been cancelled
  cancelledAssessmentCount: Int!

  # Counts total number of overall findings identified across all assessments
  totalFindingCount: Int!

  # Counts total number of adjusted findings with non-zero cvss score
  totalRiskCount: Int!

  # Counts current number of adjusted findings with non-zero cvss score
  currentRiskCount: Int!

  #
  overallApplicationScoreMean: Float

  #
  currentApplicationScoreMean: Float
}

#
type SystemOverallStatus implements SystemStatusItem {
  #
  updated: DateTime!

  #
  status: String!

  #
  status_code: Int!
}

#
type YaapTestCertificateData {
  #
  sha1: String!

  #
  debug: Boolean!

  #
  valid: Boolean!

  #
  issuer: String!

  #
  sha256: String!

  #
  expired: Boolean!

  #
  subject: String!

  #
  version: Int!

  #
  key_size: Int!

  #
  key_type: String!

  #
  self_signed: Boolean!

  #
  certificate_end: String!

  #
  certificate_type: String!

  #
  certificate_start: String!
}

# The IP scalar type represents IP addresses.
scalar IPAddress

# The SemVer scalar type represents a semantic version string.
scalar SemanticVersion
